<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>RoboViz API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>RoboViz</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 23/08/22
# ---------------------------------------------------------------------------

import PySimpleGUI as sg
from panda3d.core import CollisionTraverser
from roboviz.robotComp import RobotComp
from copy import deepcopy
import rpack
import json
from roboviz.brain import ann
from roboviz.robot import Robot
from roboviz.connection import Connection
from roboviz.brick import Brick
from roboviz.hinge import Hinge
from roboviz.environment import Environment
from roboviz.robotUtils import RobotUtils
import subprocess
from os.path import exists
import os
from panda3d.core import LineSegs
from panda3d.core import LVector2f
from panda3d.core import BoundingBox
import time
import sys
from numpy import deg2rad
from direct.gui.DirectGui import *
from direct.gui.OnscreenText import OnscreenText
from direct.showbase.ShowBase import ShowBase
from panda3d.core import WindowProperties
from panda3d.core import NodePath
from panda3d.core import TextNode
from panda3d.core import GeomNode
from panda3d.core import Mat4
from panda3d.core import LVector3f
from panda3d.core import AmbientLight
from panda3d.core import CollisionNode
from panda3d.core import CollisionRay
from panda3d.core import CollisionHandlerQueue
import math


class ann:
    &#34;&#34;&#34;This class handles all functionality for the brain of the robot.&#34;&#34;&#34;

    def __init__(self, components, inputs, outputs, weights, params, type):
        &#34;&#34;&#34;
        Constructor for the neural network.

        Initializes parameters.

        Args:
            `components`: the components that make up the output ports (RobotComp[])  
            `inputs`: the number of input neurons (int)  
            `outputs`: the number of output neurons (int)  
            `weights`: array of weights that go from the beginning to the end of the network (double[])  
            `params`: bias, gain, period and offset for output neurons (double[])  
            `type`: sigmoid/oscillator/input neuron (String[])

        &#34;&#34;&#34;
        # max is either (bias, tau, gain) or (phase offset, period, gain)
        self.MAX_PARAMS = 3

        # Branch Hip1 0 to D9
        D9 = 0
        # Branch Hip2 0 to D10
        D10 = 0
        # Branch Hip3 0 to D5
        D5 = 0
        # Branch Knee2 0 to D6
        D6 = 0
        # Branch myid1001 0 to D11
        D11 = 0
        # Branch myid1003 0 to D13
        D13 = 0
        # Branch myid1007 0 to ROLL
        ROLL = 0
        # Branch myid1018 0 to PITCH
        PITCH = 0
        self.outputPorts = []

        for i in components:
            self.outputPorts.append(i)

        NB_LIGHTSENSORS = 0
        NB_TOUCH_SENSORS = 0
        NB_IR_SENSORS = 0
        NB_SERVO_MOTORS = outputs
        NB_ROTATION_MOTORS = 0
        NB_ACC_GYRO_SENSORS = inputs

        # input ports: 0 for lightSensor,
        # type of input: 2 for Accelerometer and Gyroscope
        inputTab = []
        x = [0, 2]
        for i in range(inputs):
            inputTab.append(x)

        # FALSE if not irSensor, otherwise index of irSensor
        irIndices = [False, False, False, False, False, False]

        # first arg = value of the output port
        # second arg = type of the output:
        # 0 for position control, and 1 for velocity control

        outputTab = []
        for o in range(outputs):
            outputTab.append([self.outputPorts[o], 0])

        self.inputs = inputs
        self.outputs = outputs
        self.weights = weights
        self.params = params

        # for sigmoid: bias, tau(input or time?), gain
        # for oscilator: period, phase offset (from a central clock), gain
        # oscillator neurons do not receive any input, but rather output a sinusoid oscillation as a function of time
        self.Types = type
        # 1 = sigmoid, 3 = oscillator
        self.initNetwork()

    def initNetwork(self):
        &#34;&#34;&#34;
        Initializes the input and output states in the neural network to 0.

        The state is the output of each neuron in the network.
        &#34;&#34;&#34;
        self.state = []
        # Initialize states
        for o in range(self.outputs):
            self.state.append(0.0)

        # Initialize inputs
        for i in range(self.inputs):
            self.state.append(0.0)

    def feed(self, input):
        &#34;&#34;&#34;
        Feeds the network with an array of inputs from the sensors. Only initializes the network&#39;s current input variable.

        Args:
            `input`: the number of input neurons (int[])
        &#34;&#34;&#34;
        self.input = []
        print(&#34;Creating brain . . .&#34;)
        print(&#34;Input from sensors: &#34;, input)
        for i in range(self.inputs):
            self.input.append(input[i])

    def step(self, time):
        &#34;&#34;&#34;
        Feeds the input data into the neural network. For each input from a sensor, the data is fed into the corresponding neuron and transformed via its activation function.
        This data is propogated through the network to the output layer. The state of each neuron is changed accordingly.

        Args:
            `time`: from the python.time() library, used to set the state for the oscillator neurons (float)
        &#34;&#34;&#34;
        PI = math.pi
        baseIndexOutputWeights = (self.outputs)*(self.inputs)
        # For each hidden and output neuron, sum the state of all incoming connections
        self.activations = []
        for o in range(self.outputs):
            self.activations.append(o)
            for i in range(self.inputs):
                self.activations[o] = self.activations[o]+self.weights[(self.outputs-1)*i+o]*self.state[i]
            for i in range(self.outputs):
                self.activations[o] = self.activations[o]+self.weights[baseIndexOutputWeights]+(self.outputs-1)*i+o*self.state[i]
        # Add in biases and calculate new network state/do appropriate operation for neuron type

        for o in range(self.outputs):
            # save the next state
            if self.Types[o] == 1:
                # params are bias and gain
                self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
                self.state[o] = (1.0/(1.0 + math.exp(-1*(self.params[self.MAX_PARAMS*o+1]))))*self.activations[o]
            elif self.Types[o] == 0:
                # linear, params are bias and gain
                self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
                self.state[o] = self.params[self.MAX_PARAMS*o+1]*self.activations[o]
            elif(self.Types[o] == 3):
                # params are period, phase offset, gain (amplitude)
                period = self.params[self.MAX_PARAMS * o]
                phaseOffset = self.params[self.MAX_PARAMS * o + 1]
                gain = self.params[self.MAX_PARAMS * o + 2]
                self.state[o] = ((math.sin((2.0 * PI / period)*(time - period * phaseOffset))) + 1.0) / 2.0
                self.state[o] = (0.5 - (gain / 2.0) + self.state[o] * gain)

    def fetch(self):
        &#34;&#34;&#34;
        Concatenates the states of each neuron for this forward pass into an array.
        Returns:
            `output`: control values to be sent to motors (double[])
        &#34;&#34;&#34;
        output = []
        for o in range(self.outputs):
            output.append(self.state[o])
        # returns the output from all output nodes
        print(&#34;Output from outputPorts: &#34;, output)
        return output
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 16/08/22
# ---------------------------------------------------------------------------


class Brick(RobotComp):
    &#34;&#34;&#34;Represents a CoreComponent or FixedBrick component&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)
        &#34;&#34;&#34;
        super().__init__(id, type, root, orientation)
        self.colour = (1, 0, 0, 1)                      # colour of component
        self.mass = 50                                  # made up mass of component
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 13/08/22
# ---------------------------------------------------------------------------


def slotSwap(slot):
    &#34;&#34;&#34;
    Convert RoboGen slots to RoboViz system
    Args:
        `slot`: slot number to be swapped (int)
    Returns:
        `slot`: swapped slot number (int)
    &#34;&#34;&#34;
    if slot == 3:
        slot = 1
    elif slot == 2:
        slot = 3
    elif slot == 1:
        slot = 2
    return slot


class Connection:
    &#34;&#34;&#34;Represents a connection between 2 robot components&#34;&#34;&#34;

    def __init__(self, src, dst, src_slot, dst_slot, standardised=False):
        &#34;&#34;&#34;
        Constructor
        Args:
            `src`: source (&#39;parent&#39;) component (RobotComp)  
            `dst`: destination (&#39;child&#39;) component (RobotComp)  
            `src_slot`: side of source component to attach dest. to (int)  
            `dst_slot`: side of dest. component to attach source to (int)  
            `standardised`: whether or not the connection&#39;s slots have been standardised (boolean) **optional**
        &#34;&#34;&#34;
        self.src = src                  # source robotComp
        self.dst = dst                  # destination robotComp
        self.src_slot = src_slot        # side of connection at source
        self.dst_slot = dst_slot        # side of connection at destination
        self.standardised = standardised

    def standardiseSlots(self):
        &#34;&#34;&#34;Converts RoboGen&#39;s funky slot system to a more reasonable one (sides numbered clockwise 0-&gt;3 starting from side closest to viewer)&#34;&#34;&#34;
        # standardise hinge slots (1=2)
        if &#39;Hinge&#39; in self.src.type and self.src_slot == 1:                     # source hinge slots
            self.src_slot = 2
        if &#39;Hinge&#39; in self.dst.type and self.dst_slot == 1:                     # dest. hinge slots
            self.dst_slot = 2
        # standardise brick slots (1=2, 3=1, 2=3)
        if self.src.type == &#39;FixedBrick&#39; or self.src.type == &#39;CoreComponent&#39;:   # source brick slots
            self.src_slot = slotSwap(self.src_slot)
        if self.dst.type == &#39;FixedBrick&#39; or self.dst.type == &#39;CoreComponent&#39;:   # dest. brick slots
            self.dst_slot = slotSwap(self.dst_slot)
        self.standardised = True

    def as_dict(self):
        &#34;&#34;&#34;
        Represents a Connection object as a dictionary, for use in the RobotUtils **writeRobot** method
        Returns:
            `dict`: contains all Connection fields as a dict
        &#34;&#34;&#34;
        dict = {}
        dict[&#34;src&#34;] = self.src.id
        dict[&#34;dest&#34;] = self.dst.id
        dict[&#34;srcSlot&#34;] = self.src_slot
        dict[&#34;destSlot&#34;] = self.dst_slot
        return dict

    def __str__(self):
        &#34;&#34;&#34;
        toString for Connection object
        Returns:
            Connection in String form (String)
        &#34;&#34;&#34;
        return f&#34;src: {self.src}, dest: {self.dst}, src_slot: {self.src_slot}, dst_slot: {self.dst_slot}&#34;
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 13/08/22
# ---------------------------------------------------------------------------


SHIFT_VALUE = 5                                 # number of units robots will be moved by
ORIENTATION = {0: 0, 1: 90, 2: 180, 3: 270}     # roll in degrees relating to orientation values
# vector shifts related to directions of robot movement
SHIFT_DIRECTION = {0: LVector3f(0, SHIFT_VALUE, 0), 2: LVector3f(0, -SHIFT_VALUE, 0), 3: LVector3f(-SHIFT_VALUE, 0, 0),
                   1: LVector3f(SHIFT_VALUE, 0, 0), 4: LVector3f(0, 0, SHIFT_VALUE), 5: LVector3f(0, 0, -SHIFT_VALUE), }


class Environment(ShowBase):
    &#34;&#34;&#34;Renders environment terrain and robot components&#34;&#34;&#34;

    def __init__(self, x_length, y_length, swarm_size):
        &#34;&#34;&#34;
        Constructor   
        Args:  
            `x_length`: the x size of the environment plane (int)  
            `y_length`: the y size of the environment plane (int)  
            `swarm_size`: the number of Robots in the swarm (int)
        &#34;&#34;&#34;
        ShowBase.__init__(self)

        # DEBUG/PROTOTYPE OPTIONS
        self.setFrameRateMeter(True)
        #self.stderr_orig = sys.stderr

        # CLASS ATTRIBUTES
        self.x_length = x_length
        self.y_length = y_length
        self.swarm_size = swarm_size

        self.labels = []                                                # labels in scene
        self.label_toggle = False                                       # whether labels are enabled or not

        self.robot_pos = {}                                             # positions of robot cores
        self.focus_switch_counter = 0

        # WINDOW PROPERTIES
        props = WindowProperties()
        props.setTitle(&#39;RoboViz&#39;)
        props.setIconFilename(&#39;resources/r_icon.ico&#39;)
        self.win.requestProperties(props)

        # ROBOT SELECTION
        self.myHandler = CollisionHandlerQueue()
        self.myTraverser = CollisionTraverser()

        # attach collision ray to mouse
        pickerNode = CollisionNode(&#39;mouseRay&#39;)
        pickerNP = self.camera.attachNewNode(pickerNode)
        pickerNode.setFromCollideMask(GeomNode.getDefaultCollideMask())
        self.pickerRay = CollisionRay()
        pickerNode.addSolid(self.pickerRay)
        self.myTraverser.addCollider(pickerNP, self.myHandler)

        # NODES
        self.robotNode = NodePath(&#39;robotNode&#39;)                          # parent node to all robots in scene to
        self.robotNode.reparentTo(self.render)                          # allow for zooming out to view all robots

        self.focus = NodePath(&#39;focus&#39;)                                  # create focus point (origin) of camera
        self.focus.reparentTo(self.render)                              # for the switching of robot focus
        self.camera.reparentTo(self.focus)

        # PLANE
        self.set_background_color(0.6, 0.6, 0.6, 1)                     # set background colour to a lighter grey
        self.plane = self.loader.loadModel(&#39;./models/BAM/plane.bam&#39;)    # load &#39;terrain&#39; plane
        self.plane.setScale(self.x_length, self.y_length, 10)           # scale up to specified dimensions
        self.plane.reparentTo(self.render)
        self.plane.setZ(-20)                                            # push down so that robots render on top of it

        # LIGHTING
        alight = AmbientLight(&#39;alight&#39;)
        alight.setColor((0.4, 0.4, 0.4, 1))
        alnp = self.render.attachNewNode(alight)
        self.render.setLight(alnp)

        # ONSCREEN TEXT
        help_text = &#39;Controls:\nC - switch camera focus\nL - toggle component labels\nK - return to initial view\nH - hide this help menu&#39;  # add help text
        self.help_textNode = OnscreenText(text=help_text, pos=(1, 0.7), scale=0.04,
                                          fg=(1, 1, 1, 1), bg=(0.3, 0.3, 0.3, 0.6), align=TextNode.ACenter, mayChange=0)
        sel_text = &#39;Selected Robot: none\nSelected Component: none&#39;                                             # add selected text
        self.sel_textNode = OnscreenText(text=sel_text, pos=(1, 0.8), scale=0.04,
                                         fg=(1, 1, 1, 1), bg=(0.3, 0.3, 0.3, 0.6), align=TextNode.ACenter, mayChange=1)

        # KEYPRESS EVENTS
        # misc.
        self.accept(&#39;c&#39;, self.switchFocus)
        self.accept(&#39;l&#39;, self.toggleLabels)
        self.accept(&#39;h&#39;, lambda: self.help_textNode.show() if self.help_textNode.isHidden() else self.help_textNode.hide())
        self.accept(&#39;mouse1&#39;, self.select)
        self.accept(&#39;k&#39;, self.initialView)

        # moving robots
        self.accept(&#39;arrow_up-repeat&#39;, self.moveRobot, [0])
        self.accept(&#39;arrow_up&#39;, self.moveRobot, [0])
        self.accept(&#39;arrow_down-repeat&#39;, self.moveRobot, [2])
        self.accept(&#39;arrow_down&#39;, self.moveRobot, [2])
        self.accept(&#39;arrow_left-repeat&#39;, self.moveRobot, [3])
        self.accept(&#39;arrow_left&#39;, self.moveRobot, [3])
        self.accept(&#39;arrow_right-repeat&#39;, self.moveRobot, [1])
        self.accept(&#39;arrow_right&#39;, self.moveRobot, [1])
        self.accept(&#39;control-arrow_up-repeat&#39;, self.moveRobot, [4])
        self.accept(&#39;control-arrow_up&#39;, self.moveRobot, [4])
        self.accept(&#39;control-arrow_down-repeat&#39;, self.moveRobot, [5])
        self.accept(&#39;control-arrow_down&#39;, self.moveRobot, [5])

        # rotating robots
        self.accept(&#39;control-arrow_left&#39;, lambda: self.selected_robot.setHpr(self.render, self.selected_robot.getHpr(self.render) + LVector3f(90, 0, 0)))
        self.accept(&#39;control-arrow_right&#39;, lambda: self.selected_robot.setHpr(self.render, self.selected_robot.getHpr(self.render) + LVector3f(-90, 0, 0)))

    def finalizeExit(self):
        &#34;&#34;&#34;Overrides Panda&#39;s base finalizeExit method to prevent it from closing Python&#34;&#34;&#34;
        self.closeWindow(self.win)
        self.destroy()
        #sys.stderr = object
        raise KeyboardInterrupt                                         # to exit Panda window

    def toggleLabels(self, first=False):
        &#34;&#34;&#34;
        Toggles visibility of component labels
        Args:
            `first`: first display of labels or not (Boolean) **optional**  
        &#34;&#34;&#34;
        if first:
            for label in self.labels:
                label.node().setTextColor(1, 1, 1, 1)                   # set label colours after node flattening
                label.node().setCardColor(1, 1, 1, 0.3)
                label.setLightOff()                                     # remove lighting on labels
                label.hide()                                            # hide labels
        # if labels are &#39;on&#39;
        elif self.label_toggle == True:
            for label in self.labels:
                label.hide()                                            # hide labels
            self.label_toggle = False                                   # set to &#39;off&#39;
        # if labels are &#39;off&#39;
        else:
            for label in self.labels:
                label.show()                                            # show labels
            self.label_toggle = True                                    # set to &#39;on&#39;

    def toggleBounding(self):
        &#34;&#34;&#34;Toggles visibility of robot bounding box (selection box)&#34;&#34;&#34;
        children = self.selected_robot.getChildren()
        for child in children:
            if child.getName().split(&#39;/&#39;)[-1] == &#39;lines&#39;:               # find line node in children of root
                if child.isHidden():                                    # if bounding box is hidden
                    child.show()
                else:                                                   # if bounding box is visible
                    child.hide()
                break

    def switchFocus(self):
        &#34;&#34;&#34;Switches camera focus (origin) between robots in scene&#34;&#34;&#34;
        while self.focus_switch_counter &gt; self.swarm_size - 1:          # loop around to start of list
            self.focus_switch_counter -= self.swarm_size
        # print(f&#39;Moving camera to robot {self.focus_switch_counter} at {list(self.robot_pos.values())[self.focus_switch_counter]}&#39;)
        self.moveCamera(pos=list(self.robot_pos.values())[self.focus_switch_counter], z_dist=800)      # move camera to next robot
        self.focus_switch_counter += 1

    def moveCamera(self, pos, z_dist):
        &#34;&#34;&#34;
        Moves camera to point above pos in scene (looking down)
        Args:
            `pos`: position of camera (LVector3f)  
            `z_dist`: distance above pos that camera is placed at (int)
        &#34;&#34;&#34;
        self.focus.setPos(pos)                                          # move focus of camera
        self.disableMouse()
        self.camera.setPos(LVector3f(0, 0, z_dist))                     # move camera relative to focus
        self.camera.setHpr(0, -90, 0)                                   # make camera look down

        # make sure camera stays after mouse is enabled
        mat = Mat4(self.camera.getMat())
        mat.invertInPlace()
        self.mouseInterfaceNode.setMat(mat)
        self.enableMouse()

    def enlargeLabel(self, pickedObj):
        &#34;&#34;&#34;
        Enlarges component label when component is selected
        Args:
            `pickedObj`: newly selected component (PandaNode)
        &#34;&#34;&#34;
        for child in pickedObj.getChildren():
            # find currently selected component
            if child.getName() == &#39;id_label&#39;:
                child.setScale(6, 6, 6)                                 # enlarge label
                break
        # find previously selected component if it exists
        if hasattr(self, &#39;selected_comp&#39;):
            for child in self.selected_comp.getChildren():
                if child.getName() == &#39;id_label&#39;:
                    child.setScale(3, 3, 3)                             # return to original size
                    break

    def displayLabel(self, pos, text, parent):
        &#34;&#34;&#34;
        Displays a text label in the scene
        Args:
            `pos`: position of label (LVector3f)  
            `text`: text of label (String)  
            `parent`: parent of label (NodePath)
        &#34;&#34;&#34;
        # add text node
        label = TextNode(&#39;id_label&#39;)
        label.setText(text)
        label.setAlign(TextNode.ACenter)
        label.setCardAsMargin(0, 0, 0, 0)
        label.setCardDecal(True)

        # add node path in scene for label
        text3d = NodePath(label)                                   # add text to node
        text3d.setScale(3, 3, 3)
        text3d.setTwoSided(True)
        text3d.setBillboardPointEye()                              # make text billboard (move with camera)
        text3d.reparentTo(parent)
        text3d.setPos(self.render, pos + LVector3f(0, 0, 20))      # set pos above component model
        self.labels.append(text3d)

    def select(self):
        &#34;&#34;&#34;Determines which robot is selected (by mouse click), updates self.selected_robot to represent this&#34;&#34;&#34;
        mpos = self.mouseWatcherNode.getMouse()
        self.pickerRay.setFromLens(self.camNode, mpos.getX(), mpos.getY())

        self.myTraverser.traverse(self.render)
        # get objects close to mouse click
        if self.myHandler.getNumEntries() &gt; 0:
            self.myHandler.sortEntries()
            pickedObj = self.myHandler.getEntry(0).getIntoNodePath()    # = closest to mouse click
            pickedObj = pickedObj.findNetTag(&#39;robot&#39;)                   # find selectable objects (pre-tagged &#39;robot&#39;)
            if not pickedObj.isEmpty():
                # if a robot was previously selected
                if hasattr(self, &#39;selected_robot&#39;):
                    self.toggleBounding()                               # hide old selection box

                self.enlargeLabel(pickedObj)
                self.selected_comp = pickedObj

                # find Core comp. of robot in which the comp. is currently selected
                while True:
                    if &#39;Core&#39; not in pickedObj.getName():
                        pickedObj = pickedObj.parent
                    else:
                        break
                self.selected_robot = pickedObj                         # set class attribute to selected robot core
                self.toggleBounding()                                   # show new selection box
                # update selected robot and component displays
                if self.selected_robot.getName()[0].isdigit() and self.selected_robot.getName()[1].isdigit():
                    sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0:2] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
                else:
                    sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
                self.sel_textNode.setText(sel_text)

    def moveRobot(self, direction):
        &#34;&#34;&#34;
        Moves selected robot in the given direction for the given units relative to the camera view
        Args:
            `direction`: direction of robot movement (0:forward, 1:back, 2:left, 3:right, 4:up, 5:down) (int)  
            `units`: number of units to move robot by (int)
        &#34;&#34;&#34;
        heading = int(self.camera.getHpr()[0])
        rotation = int(self.camera.getHpr()[2])
        # trying to get the direction fo the camera and change the direction of movement so it&#39;s relative to it
        if direction not in [4, 5]:                                         # if moving along xy plane
            if heading in range(-45, 45):
                heading = 0
            elif heading in range(45, 135):
                heading = 1
            elif heading in range(135, 181) or heading in range(-180, -135):
                heading = 2
            elif heading in range(-135, -45):
                heading = 3
            if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180 (i.e. upside down)
                if direction in [1, 3]:
                    if direction == 1:
                        direction = 3
                    elif direction == 3:
                        direction = 1
            direction = int(direction) - heading
            if direction &lt; 0:
                direction += 4
        else:                                                               # if moving along z axis
            if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180
                if direction == 4:                                          # switch up and down directions
                    direction = 5
                elif direction == 5:
                    direction = 4
        shift = SHIFT_DIRECTION[direction]                                  # get direction of shift
        # move robot
        self.selected_robot.setPos(self.render, self.selected_robot.getPos(self.render) + shift)
        # update robot position
        self.robot_pos[int(self.selected_robot.getName()[0])] = self.selected_robot.getPos(self.render)

    def initialView(self):
        &#34;&#34;&#34;Moves and zooms camera so that all robots are initially placed in the camera&#39;s view&#34;&#34;&#34;
        # move + zoom camera to overlook all robots
        bounds = self.robotNode.getBounds()                                             # bounding box of all robots together
        centre = bounds.getCenter()                                                     # centre of bounding box
        fov = self.camLens.getFov()
        distance = bounds.getRadius() / math.tan(deg2rad(min(fov[0], fov[1]) * 0.6))    # calc distance needed to see all robots
        self.moveCamera(pos=centre, z_dist=distance)

    def reposition(self, pack_info):
        &#34;&#34;&#34;
        Repositions Robots and resizes environment based on the info received from the robotUtils _auto_pack_ method
        Args:
            `pack_info`: contains positions of robots and dims of environment to fit them (Tuple)
        &#34;&#34;&#34;
        positions = pack_info[0]
        self.plane.setScale(pack_info[1], pack_info[2], 10)                             # resize environment to fit all robots
        print(&#39;Resized environment to {} by {} units&#39;.format(pack_info[1], pack_info[2]))
        robots = self.robotNode.getChildren()
        # iterate through all robots in scene and reposition
        for i, robot in enumerate(robots):
            new_pos = LVector3f(positions[i][0], positions[i][1], 0)
            robot.setPos(self.render, new_pos)
            self.robot_pos[i] = new_pos                                                 # update robot position

    def renderRobot(self, robot):
        &#34;&#34;&#34;
        Renders 1 robot in the scene by iterating through its Connections
        Args:
            `robot`: robot object to render (Robot)
        &#34;&#34;&#34;
        # add position of robot core to list (for camera focus switching)
        self.robot_pos[robot.id] = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])
        robot.connections[0].src.root = True
        # loop through connections in robot
        for i, connection in enumerate(robot.connections):
            # if src comp. is the core comp.
            if connection.src.root and i == 0:
                src_path = &#39;./models/BAM/&#39; + connection.src.type + &#39;.bam&#39;   # get path of src model file
                src = self.loader.loadModel(src_path)                       # load model of src component
                # set core&#39;s position to robot core_pos
                connection.src.pos = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])

                src.setPos(connection.src.pos)                              # set position of src comp.
                src.reparentTo(self.robotNode)                              # set parent to robotNode
                src.setName(str(robot.id) + connection.src.id)              # set name of node to component ID
                src.setTag(&#39;robot&#39;, str(robot.id) + connection.src.id)      # tag as selectable

                # display robot id label text
                self.displayLabel(pos=connection.src.pos, text=&#39;Robot &#39; + str(robot.id), parent=src)
                connection.src.node = src                                   # add Panda3D node to RobotComp

            dst_path = &#39;./models/BAM/&#39; + connection.dst.type + &#39;.bam&#39;       # get path of destination model file
            dst = self.loader.loadModel(dst_path)                           # load model of source component

            if not connection.standardised:                                 # if connection isn&#39;t standardised
                connection.standardiseSlots()                               # standardise slots

            dst.setName(connection.dst.id)
            dst.setTag(&#39;robot&#39;, connection.dst.id)                          # tag as selectable
            dst.setColor(connection.dst.colour)                             # set model to relevant colour

            # calc position of dest comp based on source position
            connection.dst.pos, heading = connection.dst.calcPos(src, dst, connection)

            dst.reparentTo(connection.src.node)                             # reparent dst node to src node (add to tree)

            dst.setHpr(self.render, heading, 0, 0)                          # set heading of dest. comp.
            dst.setPos(self.render, connection.dst.pos)                     # set position of dest. comp.

            # apply orientation if comp. is a hinge
            if &#39;Hinge&#39; in connection.dst.type:
                connection.dst.orientation += connection.src.orientation
                while connection.dst.orientation &gt; 3:                       # scale orientation back to 0-&gt;3
                    connection.dst.orientation -= 4
                dst.setR(self.render, ORIENTATION[connection.dst.orientation])

            connection.dst.node = dst                                      # add Panda3D node to robotComp

        # add all comp. labels
        for i, connection in enumerate(robot.connections):
            node = connection.dst.node
            self.displayLabel(pos=node.getPos(self.render), text=node.getName(), parent=node)
        robot.drawBounds()
        # flatten nodes into one node per robot (performance optimisation)
        robot.connections[0].src.node.flattenStrong()
        # hide labels and set colours after flattening
        self.toggleLabels(first=True)

    def stepNetwork(self, ann, robot):
        &#34;&#34;&#34;
        Steps the neural network according to how much time has passed since being fed data.

        Feeds the ANN with sensor data and starts the clock. When the output from the neural network is obtained, the time is calculated,
        The robot is then stepped, which changes the positions of each of the components starting from the outwardmost output node and working toward the core component.
        The change in positon for each node corresponds to the state of the node according to the neural network.

        Args:
            `ann`: the neural network/brain of the robot (ANN)  
            `robot`: the robot the brain belongs to (Robot)
        &#34;&#34;&#34;
        startTime = time.time()
        ann.feed([1, 0, 1, 0, 1, 0])
        # feed the input nodes sensor data
        ann.step(startTime)
        # step the network
        out = ann.fetch()
        # fetch the outputs
        newTime = time.time() - startTime
        # time elapsed, feed this with the output nodes into robot &amp; step it
        robot.step(newTime, ann.outputPorts, out)
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 16/08/22
# ---------------------------------------------------------------------------


class Hinge(RobotComp):
    &#34;&#34;&#34;Represents an ActiveHinge or PassiveHinge component&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)
        &#34;&#34;&#34;
        super().__init__(id, type, root, orientation)
        self.colour = (0, 1, 0, 1)                      # colour of component
        self.mass = 20                                  # made up mass of component
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 16/08/22
# ---------------------------------------------------------------------------


LINE_THICKNESS = 1


class Robot:
    &#34;&#34;&#34;Represents a robot and its connections&#34;&#34;&#34;

    def __init__(self, id, connections, components, core_pos):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of robot (int)  
            `connections`: connections between components that make up the robot (Connection[])  
            `components`: every component in the Robot
            `core_pos`: positions of the core component of the robot (int[])
        &#34;&#34;&#34;
        self.id = id
        self.connections = connections      # list of Connections in Robot
        self.core_pos = core_pos            # position (x, y, z) of robot core component
        self.components = components        # list of RobotComps in Robot

        self.ls = LineSegs()                # for use in drawing bounding/selection box
        self.ls.setThickness(LINE_THICKNESS)
        self.ls.setColor(1, 1, 1, 1)

    def setBounds(self):
        &#34;&#34;&#34;Calculates and sets the bounds (bounding box) of the robot&#34;&#34;&#34;
        root_node = self.connections[0].src.node                            # get root node

        robot_min, robot_max = root_node.getTightBounds()                   # root node bounds
        box = BoundingBox(robot_min, robot_max)
        vertices = box.getPoints()                                          # get 8 corners of bounding box

        # calc bounds of robot bounding box
        x_max, x_min, y_max, y_min, z_max, z_min = vertices[4][0], vertices[0][0], vertices[2][1], vertices[0][1], vertices[1][2], vertices[2][2]
        self.bounds = [x_max, x_min, y_max, y_min, z_max, z_min]            # set bounds of robot

    def drawBounds(self):
        &#34;&#34;&#34;Draws LineSegs between all points of the robot bounding box&#34;&#34;&#34;
        root_node = self.connections[0].src.node                            # get root node
        robot_min, robot_max = root_node.getTightBounds(root_node)          # get bounds of whole robot
        box = BoundingBox(robot_min, robot_max)
        vertices = box.getPoints()                                          # get points of robot bounding box

        # draw &#39;side&#39; parts of selection box
        for z in range(0, len(vertices), 4):
            self.ls.moveTo(vertices[z])
            self.ls.drawTo(vertices[z + 1])
            self.ls.drawTo(vertices[z + 3])
            self.ls.drawTo(vertices[z + 2])
            self.ls.drawTo(vertices[z])

        # draw &#39;top and bottom&#39; parts of selection box
        for xy in range(0, len(vertices)//2):
            self.ls.moveTo(vertices[xy])
            self.ls.drawTo(vertices[xy + len(vertices)//2])

        bounds_node = self.ls.create()
        self.bounding_box = NodePath(bounds_node)
        self.bounding_box.reparentTo(root_node)                             # reparent bounding box to robot root
        self.bounding_box.hide()                                            # hide bounding box

    def outOfBoundsDetect(self, x_length, y_length, test=False):
        &#34;&#34;&#34;
        Determines if robot exceeds the dimensions of the environment
        Args:
            `x_length`: x length of the environment (int)  
            `y_length`: y length of the environment (int)  
            `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
        Returns:
            `out_of_bounds`: x and y values of how far the robot is out of bounds (LVector3f), returns `&#39;none&#39;` if not out of bounds
        &#34;&#34;&#34;
        if not test:
            self.setBounds()                                                # calc &amp; set bounds of robot
        out_of_bounds = LVector2f(0, 0)
        if self.bounds[0] &gt; x_length/2:                                     # if over +x edge
            out_of_bounds[0] = int(self.bounds[0] - x_length/2)
        elif self.bounds[1] &lt; -x_length/2:                                  # if over -x edge
            out_of_bounds[0] = int(x_length/2 + self.bounds[1])
        if self.bounds[2] &gt; y_length/2:                                     # if over +y edge
            out_of_bounds[1] = int(self.bounds[2] - y_length/2)
        elif self.bounds[3] &lt; -y_length/2:                                  # if over -y edge
            out_of_bounds[1] = int(y_length/2 + self.bounds[3])
        if out_of_bounds != LVector2f(0, 0):                                # if out of bounds detected
            return out_of_bounds
        else:
            return &#39;none&#39;                                                   # if no out of bounds detected

    def step(self, time, nodes, states):
        &#34;&#34;&#34;
        As the neural network is stepped, the robot components are stepped to update their positions.

        Calculates the change in position of each component according to the output of the output neurons.
        Resets the positions of all the components in the robot accordingly.

        Args:
            `time`: amount of time elapsed since the neural network was fed with data (float)  
            `nodes`: array of output nodes in the ann (RobotComp[])  
            `states`: array of output data from the output ports (double[])
        &#34;&#34;&#34;
        # step the robot
        count = len(states)-1
        # counts the position in the state array
        for comp in reversed(self.components):
            # count backwards
            for n in nodes:
                if comp == n:
                    # find the output node
                    a = comp.calcAccelaration()
                    # calculate the accelaration from the weight &amp; gravity
                    # multiply the accelaration by the output of the ann
                    comp.deltaX = 0.5*a*time*time*states[count]
                    # the states array and node array should correspond in position
                    # iterate backward to avoid having to traverse entire array of components before finding output ports
                    count = count-1
                    # calculate the change in distance
                    comp.pos = comp.pos+comp.deltaX
                    # change the destination of the component
            if comp not in nodes:
                # if not an output node
                a = comp.calcAccelaration()
                # calculate the accelaration
                comp.deltaX = 0.5 * a * time * time
                # calculate the change in distance from the acceleration
                # find the destination component &amp; get that deltaX
                for connection in self.connections:
                    if comp == connection.src:
                        comp.deltaX = comp.deltaX*(connection.src.deltaX*0.1)
                        # reduce the affect of the destination component&#39;s deltaX on the src component&#39;s deltaX by a factor of 10%
                comp.pos = comp.pos+comp.deltaX
                # update the position of the components
                # calculate acceleration but only change position by smaller and smaller as goes to core

    def __str__(self):
        &#34;&#34;&#34;
        toString for Robot object
        Returns:
            `s`: Robot in String form (String)
        &#34;&#34;&#34;
        count = 0
        s = f&#34;ID: {self.id}, Connections: &#34;
        for i in self.connections:
            s = s + f&#34;\n{count+1}: {i}&#34;
            count = count+1
        s = s + f&#34;\nCore: {self.core_pos}&#34;
        s = s+f&#34;\nTotal connections: {count}&#34;
        return s
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 16/08/22
# ---------------------------------------------------------------------------


SRC_SLOTS = {0: 180, 1: 90, 2: 0, 3: 270}           # headings related to each source slots
DST_SLOTS = {0: 0, 1: 90, 2: 180, 3: 270}           # headings related to each dest. slot
DIRECTION = {0: 0, 90: 1, 180: 2, 270: 3, 360: 0}   # directions related to each heading
BUFFER = LVector3f(1.5, 1.5, 0)                     # negative space between hinges and bricks


class RobotComp:
    &#34;&#34;&#34;Represents a component of a robot&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)  
            `deltaX`: the amount by which the component&#39;s destination is offset when the neural network is being fed (double)  
            `mass`: the mass of the component, determined by whether it is a brick or a hinge (int)
        &#34;&#34;&#34;
        self.id = id
        self.type = type                # component type
        self.root = root                # component is the root of the robot component tree
        self.orientation = orientation  # global orientation
        self.direction = 0              # global heading
        self.deltaX = 0

    def calcPos(self, src, dst, connection, test=False):
        &#34;&#34;&#34;
        Calculates the position that the component should be placed at in the scene based on the source&#39;s position
        Args:
            `src`: source Panda3D node in connection (PandaNode)  
            `dst`: destination Panda3D node in connection (PandaNode)  
            `connection`: the Connection in question (Connection)  
            `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
        Returns:
            `(dst_pos, heading)`: position and heading that component should be placed at in the scene (LVector3f, int)
        &#34;&#34;&#34;
        if not test:
            connection.dst.bounds = dst.getTightBounds()

        # only get new bounds for src comp. if it&#39;s the &#39;root&#39; comp. Otherwise just use connection.src.bounds
        if connection.src.root == True and not test:
            connection.src.bounds = src.getTightBounds()
            connection.src.root = False

        src_min, src_max = connection.src.bounds[0], connection.src.bounds[1]
        src_dims = (src_max - src_min)/2                                        # get distance from centre of source model to edge
        src_pos = connection.src.pos

        # if hinge connected to a brick, use buffer to &#39;slot&#39; together cleanly (otherwise leaves an awkward space)
        if connection.dst.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;] or connection.src.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;]:
            src_dims -= BUFFER

        dst_min, dst_max = connection.dst.bounds[0], connection.dst.bounds[1]
        dst_dims = (dst_max - dst_min)/2                                        # get distance from centre of dest model to edge

        src_slot = connection.src_slot - connection.src.direction               # get slot number relative to direction of src comp. (&#39;global&#39; slot number)
        if src_slot &lt; 0:                                                        # wrap slots around (-1=3 etc.)
            src_slot += 4

        heading = SRC_SLOTS[src_slot] + DST_SLOTS[connection.dst_slot]          # heading of dst model, dependent on src and dst slot
        connection.dst.direction = DIRECTION[heading]

        # which dims to use to calculate new pos (x or y)
        if connection.src_slot in [0, 2]:
            src_dim = src_dims[1]
        else:
            src_dim = src_dims[0]
        if connection.dst_slot in [0, 2]:
            dst_dim = dst_dims[1]
        else:
            dst_dim = dst_dims[0]

        # use src slot to determine which side of src comp. to place dest comp. on
        # LVector3f(x, y, z)
        if src_slot == 0:
            dst_pos = src_pos + LVector3f(0, -(src_dim + dst_dim), 0)           # -y (bottom)
        elif src_slot == 1:
            dst_pos = src_pos + LVector3f(-(src_dim + dst_dim), 0, 0)           # -x (left)
        elif src_slot == 2:
            dst_pos = src_pos + LVector3f(0, src_dim + dst_dim, 0)              # +y (top)
        elif src_slot == 3:
            dst_pos = src_pos + LVector3f(src_dim + dst_dim, 0, 0)              # +x (right)
        return (dst_pos, heading)

    def calcAcceleration(self):
        &#34;&#34;&#34;
        Calculates the accelaration of the component with regards to its mass and gravity
        Returns:
            `a`: the accelaration (double)
        &#34;&#34;&#34;
        a = self.mass*9.8
        return a

    def as_dict(self):
        &#34;&#34;&#34;
        Represents a RobotComp object as a dictionary, for use in the RobotUtils **writeRobot** method
        Returns:
            `dict`: contains all RobotComp fields as a dict
        &#34;&#34;&#34;
        dict = {}
        dict[&#39;id&#39;] = self.id
        dict[&#39;type&#39;] = self.type
        dict[&#39;root&#39;] = self.root
        dict[&#39;orientation&#39;] = self.orientation
        return dict

    def __str__(self):
        &#34;&#34;&#34;
        toString for RobotComp object
        Returns:
            RobotComp in String form (String)
        &#34;&#34;&#34;
        return f&#34;ID: {self.id}, Type: {self.type}, root: {self.root}, orient: {self.orientation}&#34;
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 23/08/22
# ---------------------------------------------------------------------------


# components available for adding to a robot (for building a robot)
COMPONENTS = [&#39;FixedBrick&#39;, &#39;ActiveHinge&#39;, &#39;PassiveHinge&#39;]


def formatCollisions(collisions):
    &#34;&#34;&#34;
    Formats List of collisions into displayable format
    Args:
        `collisions`: possible collisions between robots (int[][])
    Returns:
        `collision_text`: text format of robot collisions (String)
    &#34;&#34;&#34;
    collision_text = &#39;Possible Collision Between:\n&#39;
    for collision in collisions:
        collision_text += &#39;Robot {}, Robot {}\n&#39;.format(collision[0], collision[1])
    return collision_text


def formatOutOfBounds(out_of_bounds):
    &#34;&#34;&#34;
    Formats List of out of bounds robots into displayable format
    Args:
        `out_of_bounds`: robots that are out of bounds + units ([int, LVector3f])
    Returns:
        `out_of_bounds_text`: text format of out of bounds robots (String)
    &#34;&#34;&#34;
    out_of_bounds_text = &#39;&#39;
    for robot in out_of_bounds:
        out_of_bounds_text += &#39;Robot {}:\n&#39;.format(robot[0])
        if robot[1][0] != 0:
            out_of_bounds_text += &#39;x-axis = {} units\n&#39;.format(int(robot[1][0]))
        if robot[1][1] != 0:
            out_of_bounds_text += &#39;y-axis = {} units\n\n&#39;.format(int(robot[1][1]))
    return out_of_bounds_text


class RobotGUI:
    &#34;&#34;&#34;Initialises the GUI for inputting files, building robots and reporting errors&#34;&#34;&#34;

    def __init__(self, config_path=&#39;&#39;, pos_path=&#39;&#39;, robot_path=&#39;&#39;, cli=False):
        &#34;&#34;&#34;
        Constructor
        Args:
            `config_path`: file path of configuration text file (String) **optional**, only used when building a robot  
            `pos_path`: file path of robot positions text file (String) **optional**, only used when building a robot  
            `robot_path`: file path of robot JSON file (String) **optional**, only used when building a robot
            `cli`: whether or not the program is running in CLI mode (boolean) **optional**
        &#34;&#34;&#34;
        self.config_path = config_path
        self.pos_path = pos_path
        self.robot_path = robot_path
        self.working_directory = os.getcwd()
        self.out_of_bounds_all = []
        self.collisions = []
        self.cli = cli
        self.utils = RobotUtils(self.config_path, self.pos_path, self.robot_path)
        self.bgColour = &#34;Black&#34;

    def help_window(self, type):
        &#34;&#34;&#34;
        Displays the help window
        Args:
            `type`: type of help info to display (file or build), (String)
        &#34;&#34;&#34;
        # help in main GUI (loading from file)
        if type == &#39;file&#39;:
            help = &#34;To load a robot:\n  * browse for and choose a configuration, robot positions, and robot JSON file\n  * click on the &#39;Submit&#39; button to start the simulation\n(file formats are available in &#39;./docs/User_Manual.md&#39; under Appendix: File Formats)\n\nTo use auto-pack:\n  * toggle the &#39;auto-pack&#39; check box\n  * browse for and choose a configuration and robot JSON file\n  * click on the &#39;Submit&#39; button\n(positions will be automatically calculated and environment will be resized if needed)\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
        # help in build GUI (building a custom robot)
        elif type == &#39;build&#39;:
            help = &#34;To add a component:\n  * click the desired parent component in the tree\n  * select the desired type of component from the dropdown\n  * give the component an ID in the text box (&#39;comp_id&#39;)\n  * click the &#39;+&#39; button and fill in the source &amp; destination slots and orientation\n  * click on the &#39;Submit&#39; button to start the simulation\n\nTo load a robot from a JSON file click on the &#39;Browse&#39; button and select a robot JSON file\n\nBuilt robots can also be saved by checking &#39;Write to file&#39;, giving it a name and clicking &#39;Submit&#39;\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
        layout = [[sg.Multiline(default_text=help, disabled=True, size=(70, 15), no_scrollbar=True)],
                  [sg.Button(&#39;Ok&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#39;Help&#39;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, _ = window.read()
            if event == sg.WIN_CLOSED or event == &#39;Ok&#39;:
                break
        window.close()

    def error_window(self):
        &#34;&#34;&#34;Displays the error reporting window&#34;&#34;&#34;
        if len(self.collisions) &gt; 0:
            # format robot collisions
            collision_text = formatCollisions(self.collisions)
            if len(self.out_of_bounds_all) &gt; 0:
                # format out of bounds errors
                out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
                # collisions and out of bounds
                layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
            else:
                # only collisions
                layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
        elif len(self.out_of_bounds_all) &gt; 0:
            out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
            # only out of bounds
            layout = [[sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                      [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                      [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]

        sg.theme(self.bgColour)
        window = sg.Window(&#34;Errors&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, _ = window.read()
            if event == &#34;Continue&#34; or event == sg.WIN_CLOSED:
                # continue with program
                break
            if event == &#34;Cancel&#34;:
                # quit if user clicks cancel
                quit()

        window.close()

    def connection_window(self):
        &#34;&#34;&#34;
        Displays the component connection window for specifying specific connection parameters
        Returns:
            `(src_slot, dst_slot, orientation)`: source, dest slots + orientation of component ((int, int, int)) (returns (-1, -1, -1) if window closed)
        &#34;&#34;&#34;
        layout = [[sg.Text(&#39;SRC Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-SRC_COMBO-&#39;)],
                  [sg.Text(&#39;DST Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-DST_COMBO-&#39;)],
                  [sg.Text(&#39;Orientation:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-O_COMBO-&#39;)],
                  [sg.Button(&#39;Submit&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#34;Enter Slots&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, values = window.read()
            if event == sg.WIN_CLOSED:
                window.close()
                return (-1, -1, -1)     # if user closes without entering anything, return (-1, -1, -1)
            if event == &#39;Submit&#39;:
                window.close()
                # return src_slot, dst_slot and orientation
                return (values[&#39;-SRC_COMBO-&#39;], values[&#39;-DST_COMBO-&#39;], values[&#39;-O_COMBO-&#39;])

    def build_window(self):
        &#34;&#34;&#34;Displays the Robot building window&#34;&#34;&#34;
        components = []
        connections = []
        treedata = sg.TreeData()

        # place core component in tree first
        core = Brick(&#39;Core&#39;, &#39;CoreComponent&#39;, True, 0)
        components.append(core)
        treedata.insert(parent=&#39;&#39;, key=core.id, text=core.id, values=[&#39;CoreComponent&#39;, core.orientation])
        # create UI layout
        layout = [[sg.Button(&#39;+&#39;, size=3, tooltip=&#39;add component&#39;), sg.Combo(values=COMPONENTS, default_value=COMPONENTS[0], key=&#39;-C_COMBO-&#39;, tooltip=&#39;component type&#39;),
                   sg.InputText(key=&#39;-COMP_ID-&#39;, size=30, default_text=&#39;comp_id&#39;)],
                  [sg.Text(&#39;Components&#39;)],
                  [sg.Tree(data=treedata, key=&#34;-COMP_TREE-&#34;, auto_size_columns=True, num_rows=20, headings=[&#39;Type&#39;, &#39;Orientation&#39;], col0_width=30, expand_x=True, show_expanded=True), ],
                  [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(&#39;Back&#39;, tooltip=&#39;return to file menu&#39;), sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)], target=&#39;-LOAD-&#39;, tooltip=&#39;load robot JSON&#39;),
                  sg.Input(key=&#39;-LOAD-&#39;, enable_events=True, visible=False), sg.Checkbox(&#39;Write to file&#39;, default=True, key=&#39;-FILE-&#39;, tooltip=&#39;write robot to JSON&#39;),
                  sg.InputText(key=&#39;-F_NAME-&#39;, size=30, default_text=&#39;robot_name&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#34;Build a Robot&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, values = window.read()
            if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
                quit()
            if event == &#39;Back&#39;:
                # return to file menu
                break
            if event == &#39;Help&#39;:
                # show help window
                self.help_window(&#39;build&#39;)
            if event == &#39;-LOAD-&#39;:
                # user loads a JSON file from drive
                if values[&#39;-LOAD-&#39;] == &#39;&#39;:
                    # if no file selected
                    continue
                self.utils.robot_path = values[&#39;-LOAD-&#39;]
                # parse robot in from chosen file
                robot = self.utils.robotParse(1, [[0, 0, 0]], build=True)[0]
                for connection in robot.connections:
                    dst = connection.dst
                    # append components to the tree
                    treedata.Insert(parent=connection.src.id, key=dst.id, text=dst.id, values=[dst.type, dst.orientation])
                window.Element(&#39;-COMP_TREE-&#39;).update(treedata)
                components = robot.components
                connections = robot.connections

            if event == &#39;+&#39;:
                # add new component
                if values[&#39;-COMP_ID-&#39;] in treedata.tree_dict:
                    # if component id already exists in tree
                    sg.popup(&#34;Component {} already exists&#34;.format(values[&#39;-COMP_ID-&#39;]))
                    continue
                if &#39; &#39; in values[&#39;-COMP_ID-&#39;]:
                    # if component name contains spaces
                    sg.popup(&#34;No spaces in component ID&#34;)
                    continue
                if len(values[&#39;-COMP_TREE-&#39;]) == 0:
                    # if nothing selected, continue
                    sg.popup(&#34;Please select a component&#34;)
                    continue
                else:
                    sel_comp = values[&#39;-COMP_TREE-&#39;][0]

                id = values[&#39;-COMP_ID-&#39;]
                type = values[&#39;-C_COMBO-&#39;]
                # open connection window to choose slots and orientation
                src_slot, dst_slot, orientation = self.connection_window()
                # find parent in component list
                parent = next(comp for comp in components if comp.id == sel_comp)

                if src_slot == -1 or dst_slot == -1 or orientation == -1:
                    # if user exited window
                    continue
                if &#39;Hinge&#39; in parent.type:
                    # invalid src slot for hinge
                    if src_slot in [2, 3]:
                        sg.popup(&#34;Invalid source slot for Hinge&#34;)
                        continue
                if &#39;Hinge&#39; in type:
                    # invalid dst slot for hinge
                    if dst_slot in [2, 3]:
                        sg.popup(&#34;Invalid destination slot for Hinge&#34;)
                        continue
                    comp = Hinge(id, type, False, orientation)
                else:
                    comp = Brick(id, type, False, orientation)

                treedata.Insert(parent=sel_comp, key=id, text=id, values=[type, orientation])   # insert new node
                window.Element(&#39;-COMP_TREE-&#39;).update(treedata)

                components.append(comp)
                connections.append(Connection(parent, comp, src_slot, dst_slot))

            if event == &#39;Submit&#39;:
                if len(components) == 1:
                    # if only core comp. in tree
                    sg.popup(&#34;Please add more than one component&#34;)
                    continue
                if &#39; &#39; in values[&#39;-F_NAME-&#39;]:
                    # if file name contains spaces
                    sg.popup(&#34;No spaces in file name&#34;)
                    continue
                robot = Robot(0, connections, components, [0, 0, 0])
                config = [1000, 1000, 1]                                # default config for 1 robot
                if (values[&#39;-FILE-&#39;]):
                    self.utils.writeRobot(robot, values[&#39;-F_NAME-&#39;])    # write custom robot to JSON file
                window.hide()
                self.runSim(config=config, robots=[robot], build=True)  # run environment simulation with custom robot
                window.UnHide()

        window.close()

    def startGUI(self):
        &#34;&#34;&#34;Displays the file input GUI window&#34;&#34;&#34;

        LastRender = False
        # errors for file IO
        configError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
        posError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
        jsonError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)

        if(not exists(&#39;LastRender.txt&#39;)):
            # layout for if no previous file paths are found
            layout = [
                [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
                [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
                [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
                [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                    &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
            ]
        else:
            # if previous file paths found, read in and place in file path text boxes
            LastRender = True
            pos_path = &#34;&#34;
            config_path = &#34;&#34;
            robot_path = &#34;&#34;
            with open(&#39;LastRender.txt&#39;, &#39;r&#39;) as f:
                i = 0
                for line in f:
                    line = line.strip()
                    if i == 0:
                        pos_path = line
                    elif i == 1:
                        config_path = line
                    elif i == 2:
                        robot_path = line
                    i += 1
            layout = [
                [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=config_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
                [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=pos_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
                [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=robot_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
                [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                    &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
            ]

        sg.theme(self.bgColour)
        window = sg.Window(&#34;RoboViz&#34;, layout, icon=&#39;resources/r_icon.ico&#39;)

        # Main Program Loop
        while True:
            auto_pack = False
            event, values = window.read()

            if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
                break

            elif (event == &#34;Help&#34;):
                # show help window
                self.help_window(&#39;file&#39;)

            elif (event == &#34;Build&#34;):
                # switch to build window and hide file window
                window.hide()
                self.build_window()
                window.UnHide()

            # show file IO errors if a file is left out
            elif (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] == &#34;&#34;):
                configError.update(value=&#34;Configuration file not included&#34;, visible=True)
            else:
                configError.update(visible=False)

            if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-0&#34;] == &#34;&#34; and not values[&#39;-A_PACK-&#39;]):
                posError.update(value=&#34;Positions file not included&#34;, visible=True)
            else:
                posError.update(visible=False)

            if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-2&#34;] == &#34;&#34;):
                jsonError.update(value=&#34;Robots file not included&#34;, visible=True)
            else:
                jsonError.update(visible=False)

            # if all file paths given OR if config and robot paths given and auto-pack enabled (positions not required)
            if ((event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-0&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-2&#34;] != &#34;&#34;) or (event == &#39;Submit&#39; and values[&#39;-A_PACK-&#39;])):
                if values[&#39;-A_PACK-&#39;]:
                    auto_pack = True
                self.config_path = values[&#34;-FILE_PATH-&#34;]
                self.pos_path = values[&#34;-FILE_PATH-0&#34;]
                self.robot_path = values[&#34;-FILE_PATH-2&#34;]

                # GUI parsing and error checking
                self.utils = RobotUtils(self.config_path, self.pos_path, self.robot_path)
                # config parsing #
                config = self.utils.configParse()
                if not config:
                    configError.update(value=&#34;Incorrect configuration file format&#34;, visible=True)
                    continue
                else:
                    configError.update(visible=False)
                if not auto_pack:
                    # positions parsing #
                    positions = self.utils.posParse()
                    if not positions:
                        posError.update(value=&#34;Incorrect positions file format&#34;, visible=True)
                        continue
                    else:
                        posError.update(visible=False)
                else:
                    # default positions for auto-pack to use
                    positions = [[0, 0, 0]]*int(config[2])
                # robots parsing #
                robots = self.utils.robotParse(int(config[2]), positions)
                if not robots:
                    jsonError.update(value=&#34;Incorrect robot file format&#34;, visible=True)
                    continue
                elif robots == True:
                    posError.update(value=&#34;Incorrect amount of robot positions given&#34;, visible=True)
                    continue
                else:
                    jsonError.update(visible=False)
                # num. of robots in robot file do not match swarm size in config file
                if len(robots) != config[2]:
                    configError.update(value=&#34;Mismatch between swarm size and number of robots given&#34;, visible=True)
                    continue
                # num. of positions in positions file do not match swarm size in config file
                if len(positions) != config[2]:
                    posError.update(value=&#34;Mismatch between number of positions and swarm size given&#34;, visible=True)
                    continue

                # write chosen file paths to file
                lines = [self.pos_path, self.config_path, self.robot_path]
                with open(&#39;LastRender.txt&#39;, &#39;w&#39;) as f:
                    for line in lines:
                        f.write(line)
                        f.write(&#39; \n&#39;)

                window.hide()                                       # hide GUI window
                self.runSim(config, robots, auto_pack=auto_pack)    # start simulation (Panda)
                window.UnHide()                                     # show GUI window again after exiting Panda

        window.close()

    def runSim(self, config=&#39;&#39;, robots=&#39;&#39;, auto_pack=False, build=False):
        &#34;&#34;&#34;
        Creates the Environment and runs the simulation
        Args:
            `auto_pack`: whether the packing algorithm will be used to auto-position the robots (Boolean) **optional**  
            `config`: configuration parameters (int[]) **optional**, only used when building a robot  **optional**  
            `robots`: array of Robots (Robot[]) **optional**, only used when building a robot  **optional**  
            `build`: whether or not simulation is being run from robot builder (boolean) **optional**
        &#34;&#34;&#34;
        # CLI parsing and error checking
        if self.cli:
            # config parsing #
            config = self.utils.configParse()
            if not config:
                print(&#34;[ERROR] Incorrect configuration file format or file not found&#34;)
                quit()

            # positions parsing #
            positions = self.utils.posParse()
            if not positions:
                print(&#34;[ERROR] Incorrect positions file format or file not found&#34;)
                quit()

            # robot parsing #
            robots = self.utils.robotParse(int(config[2]), positions)
            if not robots:
                print(&#34;[ERROR] Incorrect robot file format or file not found&#34;)
                quit()
            elif robots == True:
                print(&#39;[ERROR] Incorrect amount of robot positions given&#39;)
                quit()
            # nun. of robots in robot file do not match swarm size in config file
            if len(robots) != config[2]:
                print(&#39;[ERROR] Mismatch between number of robots and swarm size given&#39;)
                quit()
            # num. of positions in positions file do not match swarm size in config gile
            if len(positions) != config[2]:
                print(&#39;[ERROR] Mismatch between number of positions and swarm size given&#39;)
                quit()

        env = Environment(int(config[0]), int(config[1]), int(config[2]))
        print(&#39;Rendering Robots...&#39;)
        for i, robot in enumerate(robots):                          # loop through robots in swarm
            env.renderRobot(robot)                                  # render robot
            # get any out of bounds robots
            if not self.cli and not build:
                out_of_bounds = robot.outOfBoundsDetect(int(config[0]), int(config[1]))
                if out_of_bounds != &#39;none&#39;:
                    self.out_of_bounds_all.append([i, out_of_bounds])
        print(&#39;...Done&#39;)
        if auto_pack:
            # auto-pack and reposition robots if option is selected
            print(&#39;Auto-packing Robots...&#39;)
            env.reposition(self.utils.autoPack(robots, config[0], config[1]))
            print(&#39;...Done&#39;)
        env.initialView()                                           # zoom camera out to look at all robots in scene
        if not auto_pack and not self.cli and not build:
            print(&#39;Detecting collisions...&#39;)
            # get any possible collisions between robots
            self.collisions = self.utils.collisionDetect(robots)
            print(&#39;...Done&#39;)
            # show error window if collisions or out of bounds are detected
            if len(self.collisions) &gt; 0 or len(self.out_of_bounds_all) &gt; 0:
                self.error_window()
        print(&#39;Rendering Environment...&#39;)
        env.run()
# ----------------------------------------------------------------------------
# Created By: GMLMOG016, FLDCLA001, YNGFYN001
# Created Date: 13/08/22
# ---------------------------------------------------------------------------


CREATE_BRAIN = False        # create brain or not
PACK_BUFFER = 50            # buffer between auto-packed robots
INC_AMT = 100               # amount to increase environment dims by in auto-pack if unable to fit all robots


class RobotUtils:
    &#34;&#34;&#34;Contains various utility functions (such as file IO) for creating robots&#34;&#34;&#34;

    def __init__(self, config_path, pos_path, robot_path):
        &#34;&#34;&#34;
        Constructor
        Args:
            `config_path`: file path of configuration text file (String)  
            `pos_path`: file path of robot positions text file (String)  
            `robot_path`: file path of robot JSON file (String)
        &#34;&#34;&#34;
        self.config_path = config_path
        self.pos_path = pos_path
        self.robot_path = robot_path

    def collisionDetect(self, robots):
        &#34;&#34;&#34;
        Determines if there are any possible collisions between robots in the scene
            Args:
                `robots`: list of all robots in the scene (Robot[])
            Returns
                `collisions`: possible collisions between robots (int[][])
        &#34;&#34;&#34;
        collisions = []
        for i, first_robot in enumerate(robots):
            for second_robot in robots[i + 1:]:
                # if robots cross each other&#39;s z bounds
                if first_robot.bounds[4] &gt;= second_robot.bounds[5] and first_robot.bounds[5] &lt;= second_robot.bounds[4]:
                    # if robots cross each other&#39;s x bounds
                    if first_robot.bounds[0] &gt;= second_robot.bounds[1] and first_robot.bounds[1] &lt;= second_robot.bounds[0]:
                        # if robots cross each other&#39;s y bounds
                        if first_robot.bounds[2] &gt;= second_robot.bounds[3] and first_robot.bounds[3] &lt;= second_robot.bounds[2]:
                            collisions.append([first_robot.id, second_robot.id])
        return collisions

    def createBrain(self, components, brain, neurons):
        &#34;&#34;&#34;
        Creates list of neurons based on JSON file ANN inputs
        Args:
            `components`: components in Robot (RobotComp[])  
            `brain`: connections in Robot brain (dict)  
            `neurons`: neurons in Robot brain (dict)
        &#34;&#34;&#34;
        inputNeurons = 0
        outputNeurons = 0
        outputPortIds = []
        params = []
        types = []
        for i in neurons:
            type = i[&#39;type&#39;]
            # read in json file
            gain = i[&#39;gain&#39;]
            params.append(gain)
            if type == &#39;sigmoid&#39;:
                bias = i[&#39;bias&#39;]
                params.append(bias)
                types.append(1)
                outputNeurons = outputNeurons + 1
                outputPortIds.append(i[&#39;bodyPartId&#39;])
            elif type == &#39;oscillator&#39;:
                phaseOffset = i[&#39;phaseOffset&#39;]
                period = i[&#39;period&#39;]
                params.append(period)
                params.append(phaseOffset)
                types.append(3)
                outputNeurons = outputNeurons + 1
                outputPortIds.append(i[&#39;bodyPartId&#39;])
            else:
                inputNeurons = inputNeurons+1
        weightArr = []
        destComps = []
        # set up the weights &amp; destination comps
        count = 0
        for j in components:
            for k in outputPortIds:
                if j.id in k:
                    destComps.append(j)
        for i in brain:
            weight = i[&#39;weight&#39;]
            weightArr.append(weight)
        return ann(destComps, inputNeurons, outputNeurons, weightArr, params, types)

    def writeRobot(self, robot, name):
        &#34;&#34;&#34;
        Writes custom built Robot out to relevant files
        Args:
            `robot`: Robot to be written out (Robot)  
            `name`: name of Robot JSON file (String)
        &#34;&#34;&#34;
        path = &#39;json/{}.json&#39;.format(name)
        dict_outer = {}
        dict_inner = {}
        connections = list(robot.connections)
        components = list(robot.components)

        with open(path, &#39;w&#39;) as f:
            # get all components &amp; connections as dicts
            for i, component in enumerate(components):
                components[i] = component.as_dict()
            for i, connection in enumerate(connections):
                connections[i] = connection.as_dict()

            # construct JSON file sections
            dict_inner[&#34;part&#34;] = components
            dict_inner[&#34;connection&#34;] = connections
            dict_outer[&#34;id&#34;] = robot.id
            dict_outer[&#34;body&#34;] = dict_inner

            # write to JSON file
            json.dump(dict_outer, f, indent=4)

    def posParse(self):
        &#34;&#34;&#34;
        Parses robot positions from positions file
        Returns:
            `positions`: positions of Robots in scene (int[])
        &#34;&#34;&#34;
        try:
            positions = []
            with open(self.pos_path, &#39;r&#39;) as f:
                for line in f:
                    robot_position = []
                    line = line.split(&#39; &#39;)
                    robot_position.append(int(line[0]))  # x value
                    robot_position.append(int(line[1]))  # y value
                    robot_position.append(int(line[2]))  # z value
                    positions.append(robot_position)
            return positions
        except:
            # format error or file not found
            return False

    def configParse(self):
        &#34;&#34;&#34;
        Parses environment and swarm size from configuration file
        Returns:
            `configuration`: environment and swarm size (int[])
        &#34;&#34;&#34;
        try:
            configuration = []
            with open(self.config_path, &#39;r&#39;) as f:
                for line in f:
                    configuration.append(int(line))
            return configuration
        except:
            # format error or file not found
            return False

    def robotParse(self, swarm_size, positions, build=False):
        &#34;&#34;&#34;
        Parses robot(s) from robot JSON file
        Args:
            `swarm_size`: number of robots in swarm (int)  
            `positions`: positions of each robot in swarm (int[])  
            `build`: whether or not robot is being loaded into builder (boolean) **optional**
        Returns:
            `robotArr`: all robots to be rendered in the scene (Robot[])
        &#34;&#34;&#34;
        try:
            robotArr = []
            count = 0  # counting the positions
            with open(self.robot_path, &#39;r&#39;) as f:
                data = json.load(f)
            # HETERGENEOUS SWARM
            if(&#34;swarm&#34; in data.keys()):
                swarm = data[&#34;swarm&#34;]

                for robot in swarm:
                    roboId = robot[&#34;id&#34;]
                    body = robot[&#34;body&#34;]

                    bodyComp = body[&#34;part&#34;]
                    compArr = []

                    for i in bodyComp:
                        id = i[&#39;id&#39;]
                        type = i[&#39;type&#39;]
                        root = i[&#39;root&#39;]
                        orient = i[&#39;orientation&#39;]
                        # determine component type
                        if &#39;Hinge&#39; in type:
                            newComp = Hinge(id, type, root, orient)     # create new Hinge component
                        else:
                            newComp = Brick(id, type, root, orient)     # create new Brick component

                        compArr.append(newComp)

                    bodyConnect = body[&#34;connection&#34;]
                    connArr = []

                    for i in bodyConnect:
                        src = i[&#39;src&#39;]
                        # find the component that is the source
                        for j in compArr:
                            compare = j.id
                            if src == compare:
                                src = j

                        dest = i[&#39;dest&#39;]
                        # find the component that is the destination
                        for j in compArr:
                            if dest == (j.id):
                                dest = j

                        srcSlot = i[&#39;srcSlot&#39;]
                        # find the component that is the source slot
                        for j in compArr:
                            if srcSlot == (j.id):
                                srcSlot = j

                        destSlot = i[&#39;destSlot&#39;]
                        # find the component that is the destination slot
                        for j in compArr:
                            if destSlot == (j.id):
                                srcSlot = j

                        newCon = Connection(src, dest, srcSlot, destSlot)               # construct new connection
                        connArr.append(newCon)                                          # add to list of connections

                    robot = Robot(roboId, connArr, compArr, positions[count - 1])
                    count += 1
                    robotArr.append(robot)
                return robotArr
            # HOMOGENOUS SWARM
            else:
                roboId = data[&#34;id&#34;]
                body = data[&#34;body&#34;]
                bodyComp = body[&#34;part&#34;]
                compArr = []

                for i in bodyComp:
                    id = i[&#39;id&#39;]
                    type = i[&#39;type&#39;]
                    root = i[&#39;root&#39;]
                    orient = i[&#39;orientation&#39;]
                    if &#39;Hinge&#39; in type:
                        newComp = Hinge(id, type, root, orient)                     # create new Hinge component
                    else:
                        newComp = Brick(id, type, root, orient)                     # create new Brick component
                    compArr.append(newComp)

                bodyConnect = body[&#34;connection&#34;]
                connArr = []

                for i in bodyConnect:
                    src = i[&#39;src&#39;]
                    # find the component that is the source
                    for j in compArr:
                        compare = j.id
                        if src == compare:
                            src = j

                    dest = i[&#39;dest&#39;]
                    # find the component that is the destination
                    for j in compArr:
                        if dest == (j.id):
                            dest = j

                    srcSlot = i[&#39;srcSlot&#39;]
                    # find the component that is the source slot
                    for j in compArr:
                        if srcSlot == (j.id):
                            srcSlot = j

                    destSlot = i[&#39;destSlot&#39;]
                    # find the component that is the destination slot
                    for j in compArr:
                        if destSlot == (j.id):
                            srcSlot = j

                    newCon = Connection(src, dest, srcSlot, destSlot)
                    connArr.append(newCon)
                if CREATE_BRAIN:
                    network = data[&#34;brain&#34;]
                    neurons = network[&#34;neuron&#34;]
                    brain = network[&#34;connection&#34;]
                    ann = self.createBrain(compArr, brain, neurons)
                for i in range(int(swarm_size)):                      # loop through robots in swarm
                    if not build:
                        connArr = deepcopy(connArr)
                    robotArr.append(Robot(i, connArr, compArr, positions[i]))
                return robotArr
        except IndexError:
            # means incorrect number of positions given
            return True
        except:
            # format error or file not found
            return False

    def autoPack(self, robots, x_length, y_length):
        &#34;&#34;&#34;
        Calculates automatic positioning of Robots to fit within certain bounds (resizes environment if not possible)
        Args:
            `robots`: Robots in the Environment (Robot[])  
            `x_length`: current x-dim of the environment  
            `y_length`: current y-dim of the environment
        Returns:
            `(positions, x_length, y_length)`: new positions of Robots + new dims of environment
        &#34;&#34;&#34;
        while True:
            try:
                sizes = []
                # get bounding box sizes for all robots
                for robot in robots:
                    bounds = robot.bounds
                    width = int(bounds[0]) - int(bounds[1]) + PACK_BUFFER
                    height = int(bounds[2]) - int(bounds[3]) + PACK_BUFFER
                    sizes.append((width, height))

                # calculate optimal packing positions
                positions = rpack.pack(sizes, max_width=y_length, max_height=x_length)
                box_size = rpack.bbox_size(sizes, positions)    # size of packed robots

                # adjust positions so that they&#39;re at the centre of each robot bounding box
                # (originally put at bottom left corner)
                for i, _ in enumerate(positions):
                    bounds = robots[i].bounds
                    core_pos = robot.core_pos
                    positions[i] = (positions[i][0] + core_pos[0] - bounds[1] - box_size[0]/2,
                                    positions[i][1] + core_pos[1] - bounds[3] - box_size[1]/2)
            except rpack.PackingImpossibleError:
                # can&#39;t pack into environment dims
                # resize environment and try again
                x_length += INC_AMT
                y_length += INC_AMT
                continue
            else:
                break
        return (positions, x_length, y_length)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="RoboViz.formatCollisions"><code class="name flex">
<span>def <span class="ident">formatCollisions</span></span>(<span>collisions)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats List of collisions into displayable format</p>
<h2 id="args">Args</h2>
<p><code>collisions</code>: possible collisions between robots (int[][])</p>
<h2 id="returns">Returns</h2>
<p><code>collision_text</code>: text format of robot collisions (String)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatCollisions(collisions):
    &#34;&#34;&#34;
    Formats List of collisions into displayable format
    Args:
        `collisions`: possible collisions between robots (int[][])
    Returns:
        `collision_text`: text format of robot collisions (String)
    &#34;&#34;&#34;
    collision_text = &#39;Possible Collision Between:\n&#39;
    for collision in collisions:
        collision_text += &#39;Robot {}, Robot {}\n&#39;.format(collision[0], collision[1])
    return collision_text</code></pre>
</details>
</dd>
<dt id="RoboViz.formatOutOfBounds"><code class="name flex">
<span>def <span class="ident">formatOutOfBounds</span></span>(<span>out_of_bounds)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats List of out of bounds robots into displayable format</p>
<h2 id="args">Args</h2>
<p><code>out_of_bounds</code>: robots that are out of bounds + units ([int, LVector3f])</p>
<h2 id="returns">Returns</h2>
<p><code>out_of_bounds_text</code>: text format of out of bounds robots (String)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatOutOfBounds(out_of_bounds):
    &#34;&#34;&#34;
    Formats List of out of bounds robots into displayable format
    Args:
        `out_of_bounds`: robots that are out of bounds + units ([int, LVector3f])
    Returns:
        `out_of_bounds_text`: text format of out of bounds robots (String)
    &#34;&#34;&#34;
    out_of_bounds_text = &#39;&#39;
    for robot in out_of_bounds:
        out_of_bounds_text += &#39;Robot {}:\n&#39;.format(robot[0])
        if robot[1][0] != 0:
            out_of_bounds_text += &#39;x-axis = {} units\n&#39;.format(int(robot[1][0]))
        if robot[1][1] != 0:
            out_of_bounds_text += &#39;y-axis = {} units\n\n&#39;.format(int(robot[1][1]))
    return out_of_bounds_text</code></pre>
</details>
</dd>
<dt id="RoboViz.slotSwap"><code class="name flex">
<span>def <span class="ident">slotSwap</span></span>(<span>slot)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert RoboGen slots to RoboViz system</p>
<h2 id="args">Args</h2>
<p><code>slot</code>: slot number to be swapped (int)</p>
<h2 id="returns">Returns</h2>
<p><code>slot</code>: swapped slot number (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slotSwap(slot):
    &#34;&#34;&#34;
    Convert RoboGen slots to RoboViz system
    Args:
        `slot`: slot number to be swapped (int)
    Returns:
        `slot`: swapped slot number (int)
    &#34;&#34;&#34;
    if slot == 3:
        slot = 1
    elif slot == 2:
        slot = 3
    elif slot == 1:
        slot = 2
    return slot</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="RoboViz.Brick"><code class="flex name class">
<span>class <span class="ident">Brick</span></span>
<span>(</span><span>id, type, root, orientation)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a CoreComponent or FixedBrick component</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>id</code>: ID of Brick (String)<br>
<code>type</code>: type of brick component (String)<br>
<code>root</code>: whether this brick is the core of the robot or not (boolean)<br>
<code>orientation</code>: orientation (roll) of this component relative to its parent (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Brick(RobotComp):
    &#34;&#34;&#34;Represents a CoreComponent or FixedBrick component&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)
        &#34;&#34;&#34;
        super().__init__(id, type, root, orientation)
        self.colour = (1, 0, 0, 1)                      # colour of component
        self.mass = 50                                  # made up mass of component</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>roboviz.robotComp.RobotComp</li>
</ul>
</dd>
<dt id="RoboViz.Connection"><code class="flex name class">
<span>class <span class="ident">Connection</span></span>
<span>(</span><span>src, dst, src_slot, dst_slot, standardised=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a connection between 2 robot components</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>src</code>: source ('parent') component (RobotComp)<br>
<code>dst</code>: destination ('child') component (RobotComp)<br>
<code>src_slot</code>: side of source component to attach dest. to (int)<br>
<code>dst_slot</code>: side of dest. component to attach source to (int)<br>
<code>standardised</code>: whether or not the connection's slots have been standardised (boolean) <strong>optional</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connection:
    &#34;&#34;&#34;Represents a connection between 2 robot components&#34;&#34;&#34;

    def __init__(self, src, dst, src_slot, dst_slot, standardised=False):
        &#34;&#34;&#34;
        Constructor
        Args:
            `src`: source (&#39;parent&#39;) component (RobotComp)  
            `dst`: destination (&#39;child&#39;) component (RobotComp)  
            `src_slot`: side of source component to attach dest. to (int)  
            `dst_slot`: side of dest. component to attach source to (int)  
            `standardised`: whether or not the connection&#39;s slots have been standardised (boolean) **optional**
        &#34;&#34;&#34;
        self.src = src                  # source robotComp
        self.dst = dst                  # destination robotComp
        self.src_slot = src_slot        # side of connection at source
        self.dst_slot = dst_slot        # side of connection at destination
        self.standardised = standardised

    def standardiseSlots(self):
        &#34;&#34;&#34;Converts RoboGen&#39;s funky slot system to a more reasonable one (sides numbered clockwise 0-&gt;3 starting from side closest to viewer)&#34;&#34;&#34;
        # standardise hinge slots (1=2)
        if &#39;Hinge&#39; in self.src.type and self.src_slot == 1:                     # source hinge slots
            self.src_slot = 2
        if &#39;Hinge&#39; in self.dst.type and self.dst_slot == 1:                     # dest. hinge slots
            self.dst_slot = 2
        # standardise brick slots (1=2, 3=1, 2=3)
        if self.src.type == &#39;FixedBrick&#39; or self.src.type == &#39;CoreComponent&#39;:   # source brick slots
            self.src_slot = slotSwap(self.src_slot)
        if self.dst.type == &#39;FixedBrick&#39; or self.dst.type == &#39;CoreComponent&#39;:   # dest. brick slots
            self.dst_slot = slotSwap(self.dst_slot)
        self.standardised = True

    def as_dict(self):
        &#34;&#34;&#34;
        Represents a Connection object as a dictionary, for use in the RobotUtils **writeRobot** method
        Returns:
            `dict`: contains all Connection fields as a dict
        &#34;&#34;&#34;
        dict = {}
        dict[&#34;src&#34;] = self.src.id
        dict[&#34;dest&#34;] = self.dst.id
        dict[&#34;srcSlot&#34;] = self.src_slot
        dict[&#34;destSlot&#34;] = self.dst_slot
        return dict

    def __str__(self):
        &#34;&#34;&#34;
        toString for Connection object
        Returns:
            Connection in String form (String)
        &#34;&#34;&#34;
        return f&#34;src: {self.src}, dest: {self.dst}, src_slot: {self.src_slot}, dst_slot: {self.dst_slot}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.Connection.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a Connection object as a dictionary, for use in the RobotUtils <strong>writeRobot</strong> method</p>
<h2 id="returns">Returns</h2>
<p><code>dict</code>: contains all Connection fields as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self):
    &#34;&#34;&#34;
    Represents a Connection object as a dictionary, for use in the RobotUtils **writeRobot** method
    Returns:
        `dict`: contains all Connection fields as a dict
    &#34;&#34;&#34;
    dict = {}
    dict[&#34;src&#34;] = self.src.id
    dict[&#34;dest&#34;] = self.dst.id
    dict[&#34;srcSlot&#34;] = self.src_slot
    dict[&#34;destSlot&#34;] = self.dst_slot
    return dict</code></pre>
</details>
</dd>
<dt id="RoboViz.Connection.standardiseSlots"><code class="name flex">
<span>def <span class="ident">standardiseSlots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts RoboGen's funky slot system to a more reasonable one (sides numbered clockwise 0-&gt;3 starting from side closest to viewer)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardiseSlots(self):
    &#34;&#34;&#34;Converts RoboGen&#39;s funky slot system to a more reasonable one (sides numbered clockwise 0-&gt;3 starting from side closest to viewer)&#34;&#34;&#34;
    # standardise hinge slots (1=2)
    if &#39;Hinge&#39; in self.src.type and self.src_slot == 1:                     # source hinge slots
        self.src_slot = 2
    if &#39;Hinge&#39; in self.dst.type and self.dst_slot == 1:                     # dest. hinge slots
        self.dst_slot = 2
    # standardise brick slots (1=2, 3=1, 2=3)
    if self.src.type == &#39;FixedBrick&#39; or self.src.type == &#39;CoreComponent&#39;:   # source brick slots
        self.src_slot = slotSwap(self.src_slot)
    if self.dst.type == &#39;FixedBrick&#39; or self.dst.type == &#39;CoreComponent&#39;:   # dest. brick slots
        self.dst_slot = slotSwap(self.dst_slot)
    self.standardised = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>x_length, y_length, swarm_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders environment terrain and robot components</p>
<p>Constructor <br>
Args:<br>
<code>x_length</code>: the x size of the environment plane (int)<br>
<code>y_length</code>: the y size of the environment plane (int)<br>
<code>swarm_size</code>: the number of Robots in the swarm (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment(ShowBase):
    &#34;&#34;&#34;Renders environment terrain and robot components&#34;&#34;&#34;

    def __init__(self, x_length, y_length, swarm_size):
        &#34;&#34;&#34;
        Constructor   
        Args:  
            `x_length`: the x size of the environment plane (int)  
            `y_length`: the y size of the environment plane (int)  
            `swarm_size`: the number of Robots in the swarm (int)
        &#34;&#34;&#34;
        ShowBase.__init__(self)

        # DEBUG/PROTOTYPE OPTIONS
        self.setFrameRateMeter(True)
        #self.stderr_orig = sys.stderr

        # CLASS ATTRIBUTES
        self.x_length = x_length
        self.y_length = y_length
        self.swarm_size = swarm_size

        self.labels = []                                                # labels in scene
        self.label_toggle = False                                       # whether labels are enabled or not

        self.robot_pos = {}                                             # positions of robot cores
        self.focus_switch_counter = 0

        # WINDOW PROPERTIES
        props = WindowProperties()
        props.setTitle(&#39;RoboViz&#39;)
        props.setIconFilename(&#39;resources/r_icon.ico&#39;)
        self.win.requestProperties(props)

        # ROBOT SELECTION
        self.myHandler = CollisionHandlerQueue()
        self.myTraverser = CollisionTraverser()

        # attach collision ray to mouse
        pickerNode = CollisionNode(&#39;mouseRay&#39;)
        pickerNP = self.camera.attachNewNode(pickerNode)
        pickerNode.setFromCollideMask(GeomNode.getDefaultCollideMask())
        self.pickerRay = CollisionRay()
        pickerNode.addSolid(self.pickerRay)
        self.myTraverser.addCollider(pickerNP, self.myHandler)

        # NODES
        self.robotNode = NodePath(&#39;robotNode&#39;)                          # parent node to all robots in scene to
        self.robotNode.reparentTo(self.render)                          # allow for zooming out to view all robots

        self.focus = NodePath(&#39;focus&#39;)                                  # create focus point (origin) of camera
        self.focus.reparentTo(self.render)                              # for the switching of robot focus
        self.camera.reparentTo(self.focus)

        # PLANE
        self.set_background_color(0.6, 0.6, 0.6, 1)                     # set background colour to a lighter grey
        self.plane = self.loader.loadModel(&#39;./models/BAM/plane.bam&#39;)    # load &#39;terrain&#39; plane
        self.plane.setScale(self.x_length, self.y_length, 10)           # scale up to specified dimensions
        self.plane.reparentTo(self.render)
        self.plane.setZ(-20)                                            # push down so that robots render on top of it

        # LIGHTING
        alight = AmbientLight(&#39;alight&#39;)
        alight.setColor((0.4, 0.4, 0.4, 1))
        alnp = self.render.attachNewNode(alight)
        self.render.setLight(alnp)

        # ONSCREEN TEXT
        help_text = &#39;Controls:\nC - switch camera focus\nL - toggle component labels\nK - return to initial view\nH - hide this help menu&#39;  # add help text
        self.help_textNode = OnscreenText(text=help_text, pos=(1, 0.7), scale=0.04,
                                          fg=(1, 1, 1, 1), bg=(0.3, 0.3, 0.3, 0.6), align=TextNode.ACenter, mayChange=0)
        sel_text = &#39;Selected Robot: none\nSelected Component: none&#39;                                             # add selected text
        self.sel_textNode = OnscreenText(text=sel_text, pos=(1, 0.8), scale=0.04,
                                         fg=(1, 1, 1, 1), bg=(0.3, 0.3, 0.3, 0.6), align=TextNode.ACenter, mayChange=1)

        # KEYPRESS EVENTS
        # misc.
        self.accept(&#39;c&#39;, self.switchFocus)
        self.accept(&#39;l&#39;, self.toggleLabels)
        self.accept(&#39;h&#39;, lambda: self.help_textNode.show() if self.help_textNode.isHidden() else self.help_textNode.hide())
        self.accept(&#39;mouse1&#39;, self.select)
        self.accept(&#39;k&#39;, self.initialView)

        # moving robots
        self.accept(&#39;arrow_up-repeat&#39;, self.moveRobot, [0])
        self.accept(&#39;arrow_up&#39;, self.moveRobot, [0])
        self.accept(&#39;arrow_down-repeat&#39;, self.moveRobot, [2])
        self.accept(&#39;arrow_down&#39;, self.moveRobot, [2])
        self.accept(&#39;arrow_left-repeat&#39;, self.moveRobot, [3])
        self.accept(&#39;arrow_left&#39;, self.moveRobot, [3])
        self.accept(&#39;arrow_right-repeat&#39;, self.moveRobot, [1])
        self.accept(&#39;arrow_right&#39;, self.moveRobot, [1])
        self.accept(&#39;control-arrow_up-repeat&#39;, self.moveRobot, [4])
        self.accept(&#39;control-arrow_up&#39;, self.moveRobot, [4])
        self.accept(&#39;control-arrow_down-repeat&#39;, self.moveRobot, [5])
        self.accept(&#39;control-arrow_down&#39;, self.moveRobot, [5])

        # rotating robots
        self.accept(&#39;control-arrow_left&#39;, lambda: self.selected_robot.setHpr(self.render, self.selected_robot.getHpr(self.render) + LVector3f(90, 0, 0)))
        self.accept(&#39;control-arrow_right&#39;, lambda: self.selected_robot.setHpr(self.render, self.selected_robot.getHpr(self.render) + LVector3f(-90, 0, 0)))

    def finalizeExit(self):
        &#34;&#34;&#34;Overrides Panda&#39;s base finalizeExit method to prevent it from closing Python&#34;&#34;&#34;
        self.closeWindow(self.win)
        self.destroy()
        #sys.stderr = object
        raise KeyboardInterrupt                                         # to exit Panda window

    def toggleLabels(self, first=False):
        &#34;&#34;&#34;
        Toggles visibility of component labels
        Args:
            `first`: first display of labels or not (Boolean) **optional**  
        &#34;&#34;&#34;
        if first:
            for label in self.labels:
                label.node().setTextColor(1, 1, 1, 1)                   # set label colours after node flattening
                label.node().setCardColor(1, 1, 1, 0.3)
                label.setLightOff()                                     # remove lighting on labels
                label.hide()                                            # hide labels
        # if labels are &#39;on&#39;
        elif self.label_toggle == True:
            for label in self.labels:
                label.hide()                                            # hide labels
            self.label_toggle = False                                   # set to &#39;off&#39;
        # if labels are &#39;off&#39;
        else:
            for label in self.labels:
                label.show()                                            # show labels
            self.label_toggle = True                                    # set to &#39;on&#39;

    def toggleBounding(self):
        &#34;&#34;&#34;Toggles visibility of robot bounding box (selection box)&#34;&#34;&#34;
        children = self.selected_robot.getChildren()
        for child in children:
            if child.getName().split(&#39;/&#39;)[-1] == &#39;lines&#39;:               # find line node in children of root
                if child.isHidden():                                    # if bounding box is hidden
                    child.show()
                else:                                                   # if bounding box is visible
                    child.hide()
                break

    def switchFocus(self):
        &#34;&#34;&#34;Switches camera focus (origin) between robots in scene&#34;&#34;&#34;
        while self.focus_switch_counter &gt; self.swarm_size - 1:          # loop around to start of list
            self.focus_switch_counter -= self.swarm_size
        # print(f&#39;Moving camera to robot {self.focus_switch_counter} at {list(self.robot_pos.values())[self.focus_switch_counter]}&#39;)
        self.moveCamera(pos=list(self.robot_pos.values())[self.focus_switch_counter], z_dist=800)      # move camera to next robot
        self.focus_switch_counter += 1

    def moveCamera(self, pos, z_dist):
        &#34;&#34;&#34;
        Moves camera to point above pos in scene (looking down)
        Args:
            `pos`: position of camera (LVector3f)  
            `z_dist`: distance above pos that camera is placed at (int)
        &#34;&#34;&#34;
        self.focus.setPos(pos)                                          # move focus of camera
        self.disableMouse()
        self.camera.setPos(LVector3f(0, 0, z_dist))                     # move camera relative to focus
        self.camera.setHpr(0, -90, 0)                                   # make camera look down

        # make sure camera stays after mouse is enabled
        mat = Mat4(self.camera.getMat())
        mat.invertInPlace()
        self.mouseInterfaceNode.setMat(mat)
        self.enableMouse()

    def enlargeLabel(self, pickedObj):
        &#34;&#34;&#34;
        Enlarges component label when component is selected
        Args:
            `pickedObj`: newly selected component (PandaNode)
        &#34;&#34;&#34;
        for child in pickedObj.getChildren():
            # find currently selected component
            if child.getName() == &#39;id_label&#39;:
                child.setScale(6, 6, 6)                                 # enlarge label
                break
        # find previously selected component if it exists
        if hasattr(self, &#39;selected_comp&#39;):
            for child in self.selected_comp.getChildren():
                if child.getName() == &#39;id_label&#39;:
                    child.setScale(3, 3, 3)                             # return to original size
                    break

    def displayLabel(self, pos, text, parent):
        &#34;&#34;&#34;
        Displays a text label in the scene
        Args:
            `pos`: position of label (LVector3f)  
            `text`: text of label (String)  
            `parent`: parent of label (NodePath)
        &#34;&#34;&#34;
        # add text node
        label = TextNode(&#39;id_label&#39;)
        label.setText(text)
        label.setAlign(TextNode.ACenter)
        label.setCardAsMargin(0, 0, 0, 0)
        label.setCardDecal(True)

        # add node path in scene for label
        text3d = NodePath(label)                                   # add text to node
        text3d.setScale(3, 3, 3)
        text3d.setTwoSided(True)
        text3d.setBillboardPointEye()                              # make text billboard (move with camera)
        text3d.reparentTo(parent)
        text3d.setPos(self.render, pos + LVector3f(0, 0, 20))      # set pos above component model
        self.labels.append(text3d)

    def select(self):
        &#34;&#34;&#34;Determines which robot is selected (by mouse click), updates self.selected_robot to represent this&#34;&#34;&#34;
        mpos = self.mouseWatcherNode.getMouse()
        self.pickerRay.setFromLens(self.camNode, mpos.getX(), mpos.getY())

        self.myTraverser.traverse(self.render)
        # get objects close to mouse click
        if self.myHandler.getNumEntries() &gt; 0:
            self.myHandler.sortEntries()
            pickedObj = self.myHandler.getEntry(0).getIntoNodePath()    # = closest to mouse click
            pickedObj = pickedObj.findNetTag(&#39;robot&#39;)                   # find selectable objects (pre-tagged &#39;robot&#39;)
            if not pickedObj.isEmpty():
                # if a robot was previously selected
                if hasattr(self, &#39;selected_robot&#39;):
                    self.toggleBounding()                               # hide old selection box

                self.enlargeLabel(pickedObj)
                self.selected_comp = pickedObj

                # find Core comp. of robot in which the comp. is currently selected
                while True:
                    if &#39;Core&#39; not in pickedObj.getName():
                        pickedObj = pickedObj.parent
                    else:
                        break
                self.selected_robot = pickedObj                         # set class attribute to selected robot core
                self.toggleBounding()                                   # show new selection box
                # update selected robot and component displays
                if self.selected_robot.getName()[0].isdigit() and self.selected_robot.getName()[1].isdigit():
                    sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0:2] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
                else:
                    sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
                self.sel_textNode.setText(sel_text)

    def moveRobot(self, direction):
        &#34;&#34;&#34;
        Moves selected robot in the given direction for the given units relative to the camera view
        Args:
            `direction`: direction of robot movement (0:forward, 1:back, 2:left, 3:right, 4:up, 5:down) (int)  
            `units`: number of units to move robot by (int)
        &#34;&#34;&#34;
        heading = int(self.camera.getHpr()[0])
        rotation = int(self.camera.getHpr()[2])
        # trying to get the direction fo the camera and change the direction of movement so it&#39;s relative to it
        if direction not in [4, 5]:                                         # if moving along xy plane
            if heading in range(-45, 45):
                heading = 0
            elif heading in range(45, 135):
                heading = 1
            elif heading in range(135, 181) or heading in range(-180, -135):
                heading = 2
            elif heading in range(-135, -45):
                heading = 3
            if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180 (i.e. upside down)
                if direction in [1, 3]:
                    if direction == 1:
                        direction = 3
                    elif direction == 3:
                        direction = 1
            direction = int(direction) - heading
            if direction &lt; 0:
                direction += 4
        else:                                                               # if moving along z axis
            if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180
                if direction == 4:                                          # switch up and down directions
                    direction = 5
                elif direction == 5:
                    direction = 4
        shift = SHIFT_DIRECTION[direction]                                  # get direction of shift
        # move robot
        self.selected_robot.setPos(self.render, self.selected_robot.getPos(self.render) + shift)
        # update robot position
        self.robot_pos[int(self.selected_robot.getName()[0])] = self.selected_robot.getPos(self.render)

    def initialView(self):
        &#34;&#34;&#34;Moves and zooms camera so that all robots are initially placed in the camera&#39;s view&#34;&#34;&#34;
        # move + zoom camera to overlook all robots
        bounds = self.robotNode.getBounds()                                             # bounding box of all robots together
        centre = bounds.getCenter()                                                     # centre of bounding box
        fov = self.camLens.getFov()
        distance = bounds.getRadius() / math.tan(deg2rad(min(fov[0], fov[1]) * 0.6))    # calc distance needed to see all robots
        self.moveCamera(pos=centre, z_dist=distance)

    def reposition(self, pack_info):
        &#34;&#34;&#34;
        Repositions Robots and resizes environment based on the info received from the robotUtils _auto_pack_ method
        Args:
            `pack_info`: contains positions of robots and dims of environment to fit them (Tuple)
        &#34;&#34;&#34;
        positions = pack_info[0]
        self.plane.setScale(pack_info[1], pack_info[2], 10)                             # resize environment to fit all robots
        print(&#39;Resized environment to {} by {} units&#39;.format(pack_info[1], pack_info[2]))
        robots = self.robotNode.getChildren()
        # iterate through all robots in scene and reposition
        for i, robot in enumerate(robots):
            new_pos = LVector3f(positions[i][0], positions[i][1], 0)
            robot.setPos(self.render, new_pos)
            self.robot_pos[i] = new_pos                                                 # update robot position

    def renderRobot(self, robot):
        &#34;&#34;&#34;
        Renders 1 robot in the scene by iterating through its Connections
        Args:
            `robot`: robot object to render (Robot)
        &#34;&#34;&#34;
        # add position of robot core to list (for camera focus switching)
        self.robot_pos[robot.id] = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])
        robot.connections[0].src.root = True
        # loop through connections in robot
        for i, connection in enumerate(robot.connections):
            # if src comp. is the core comp.
            if connection.src.root and i == 0:
                src_path = &#39;./models/BAM/&#39; + connection.src.type + &#39;.bam&#39;   # get path of src model file
                src = self.loader.loadModel(src_path)                       # load model of src component
                # set core&#39;s position to robot core_pos
                connection.src.pos = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])

                src.setPos(connection.src.pos)                              # set position of src comp.
                src.reparentTo(self.robotNode)                              # set parent to robotNode
                src.setName(str(robot.id) + connection.src.id)              # set name of node to component ID
                src.setTag(&#39;robot&#39;, str(robot.id) + connection.src.id)      # tag as selectable

                # display robot id label text
                self.displayLabel(pos=connection.src.pos, text=&#39;Robot &#39; + str(robot.id), parent=src)
                connection.src.node = src                                   # add Panda3D node to RobotComp

            dst_path = &#39;./models/BAM/&#39; + connection.dst.type + &#39;.bam&#39;       # get path of destination model file
            dst = self.loader.loadModel(dst_path)                           # load model of source component

            if not connection.standardised:                                 # if connection isn&#39;t standardised
                connection.standardiseSlots()                               # standardise slots

            dst.setName(connection.dst.id)
            dst.setTag(&#39;robot&#39;, connection.dst.id)                          # tag as selectable
            dst.setColor(connection.dst.colour)                             # set model to relevant colour

            # calc position of dest comp based on source position
            connection.dst.pos, heading = connection.dst.calcPos(src, dst, connection)

            dst.reparentTo(connection.src.node)                             # reparent dst node to src node (add to tree)

            dst.setHpr(self.render, heading, 0, 0)                          # set heading of dest. comp.
            dst.setPos(self.render, connection.dst.pos)                     # set position of dest. comp.

            # apply orientation if comp. is a hinge
            if &#39;Hinge&#39; in connection.dst.type:
                connection.dst.orientation += connection.src.orientation
                while connection.dst.orientation &gt; 3:                       # scale orientation back to 0-&gt;3
                    connection.dst.orientation -= 4
                dst.setR(self.render, ORIENTATION[connection.dst.orientation])

            connection.dst.node = dst                                      # add Panda3D node to robotComp

        # add all comp. labels
        for i, connection in enumerate(robot.connections):
            node = connection.dst.node
            self.displayLabel(pos=node.getPos(self.render), text=node.getName(), parent=node)
        robot.drawBounds()
        # flatten nodes into one node per robot (performance optimisation)
        robot.connections[0].src.node.flattenStrong()
        # hide labels and set colours after flattening
        self.toggleLabels(first=True)

    def stepNetwork(self, ann, robot):
        &#34;&#34;&#34;
        Steps the neural network according to how much time has passed since being fed data.

        Feeds the ANN with sensor data and starts the clock. When the output from the neural network is obtained, the time is calculated,
        The robot is then stepped, which changes the positions of each of the components starting from the outwardmost output node and working toward the core component.
        The change in positon for each node corresponds to the state of the node according to the neural network.

        Args:
            `ann`: the neural network/brain of the robot (ANN)  
            `robot`: the robot the brain belongs to (Robot)
        &#34;&#34;&#34;
        startTime = time.time()
        ann.feed([1, 0, 1, 0, 1, 0])
        # feed the input nodes sensor data
        ann.step(startTime)
        # step the network
        out = ann.fetch()
        # fetch the outputs
        newTime = time.time() - startTime
        # time elapsed, feed this with the output nodes into robot &amp; step it
        robot.step(newTime, ann.outputPorts, out)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>direct.showbase.ShowBase.ShowBase</li>
<li>direct.showbase.DirectObject.DirectObject</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.Environment.displayLabel"><code class="name flex">
<span>def <span class="ident">displayLabel</span></span>(<span>self, pos, text, parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a text label in the scene</p>
<h2 id="args">Args</h2>
<p><code>pos</code>: position of label (LVector3f)<br>
<code>text</code>: text of label (String)<br>
<code>parent</code>: parent of label (NodePath)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayLabel(self, pos, text, parent):
    &#34;&#34;&#34;
    Displays a text label in the scene
    Args:
        `pos`: position of label (LVector3f)  
        `text`: text of label (String)  
        `parent`: parent of label (NodePath)
    &#34;&#34;&#34;
    # add text node
    label = TextNode(&#39;id_label&#39;)
    label.setText(text)
    label.setAlign(TextNode.ACenter)
    label.setCardAsMargin(0, 0, 0, 0)
    label.setCardDecal(True)

    # add node path in scene for label
    text3d = NodePath(label)                                   # add text to node
    text3d.setScale(3, 3, 3)
    text3d.setTwoSided(True)
    text3d.setBillboardPointEye()                              # make text billboard (move with camera)
    text3d.reparentTo(parent)
    text3d.setPos(self.render, pos + LVector3f(0, 0, 20))      # set pos above component model
    self.labels.append(text3d)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.enlargeLabel"><code class="name flex">
<span>def <span class="ident">enlargeLabel</span></span>(<span>self, pickedObj)</span>
</code></dt>
<dd>
<div class="desc"><p>Enlarges component label when component is selected</p>
<h2 id="args">Args</h2>
<p><code>pickedObj</code>: newly selected component (PandaNode)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enlargeLabel(self, pickedObj):
    &#34;&#34;&#34;
    Enlarges component label when component is selected
    Args:
        `pickedObj`: newly selected component (PandaNode)
    &#34;&#34;&#34;
    for child in pickedObj.getChildren():
        # find currently selected component
        if child.getName() == &#39;id_label&#39;:
            child.setScale(6, 6, 6)                                 # enlarge label
            break
    # find previously selected component if it exists
    if hasattr(self, &#39;selected_comp&#39;):
        for child in self.selected_comp.getChildren():
            if child.getName() == &#39;id_label&#39;:
                child.setScale(3, 3, 3)                             # return to original size
                break</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.finalizeExit"><code class="name flex">
<span>def <span class="ident">finalizeExit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides Panda's base finalizeExit method to prevent it from closing Python</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalizeExit(self):
    &#34;&#34;&#34;Overrides Panda&#39;s base finalizeExit method to prevent it from closing Python&#34;&#34;&#34;
    self.closeWindow(self.win)
    self.destroy()
    #sys.stderr = object
    raise KeyboardInterrupt                                         # to exit Panda window</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.initialView"><code class="name flex">
<span>def <span class="ident">initialView</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves and zooms camera so that all robots are initially placed in the camera's view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialView(self):
    &#34;&#34;&#34;Moves and zooms camera so that all robots are initially placed in the camera&#39;s view&#34;&#34;&#34;
    # move + zoom camera to overlook all robots
    bounds = self.robotNode.getBounds()                                             # bounding box of all robots together
    centre = bounds.getCenter()                                                     # centre of bounding box
    fov = self.camLens.getFov()
    distance = bounds.getRadius() / math.tan(deg2rad(min(fov[0], fov[1]) * 0.6))    # calc distance needed to see all robots
    self.moveCamera(pos=centre, z_dist=distance)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.moveCamera"><code class="name flex">
<span>def <span class="ident">moveCamera</span></span>(<span>self, pos, z_dist)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves camera to point above pos in scene (looking down)</p>
<h2 id="args">Args</h2>
<p><code>pos</code>: position of camera (LVector3f)<br>
<code>z_dist</code>: distance above pos that camera is placed at (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveCamera(self, pos, z_dist):
    &#34;&#34;&#34;
    Moves camera to point above pos in scene (looking down)
    Args:
        `pos`: position of camera (LVector3f)  
        `z_dist`: distance above pos that camera is placed at (int)
    &#34;&#34;&#34;
    self.focus.setPos(pos)                                          # move focus of camera
    self.disableMouse()
    self.camera.setPos(LVector3f(0, 0, z_dist))                     # move camera relative to focus
    self.camera.setHpr(0, -90, 0)                                   # make camera look down

    # make sure camera stays after mouse is enabled
    mat = Mat4(self.camera.getMat())
    mat.invertInPlace()
    self.mouseInterfaceNode.setMat(mat)
    self.enableMouse()</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.moveRobot"><code class="name flex">
<span>def <span class="ident">moveRobot</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves selected robot in the given direction for the given units relative to the camera view</p>
<h2 id="args">Args</h2>
<p><code>direction</code>: direction of robot movement (0:forward, 1:back, 2:left, 3:right, 4:up, 5:down) (int)<br>
<code>units</code>: number of units to move robot by (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveRobot(self, direction):
    &#34;&#34;&#34;
    Moves selected robot in the given direction for the given units relative to the camera view
    Args:
        `direction`: direction of robot movement (0:forward, 1:back, 2:left, 3:right, 4:up, 5:down) (int)  
        `units`: number of units to move robot by (int)
    &#34;&#34;&#34;
    heading = int(self.camera.getHpr()[0])
    rotation = int(self.camera.getHpr()[2])
    # trying to get the direction fo the camera and change the direction of movement so it&#39;s relative to it
    if direction not in [4, 5]:                                         # if moving along xy plane
        if heading in range(-45, 45):
            heading = 0
        elif heading in range(45, 135):
            heading = 1
        elif heading in range(135, 181) or heading in range(-180, -135):
            heading = 2
        elif heading in range(-135, -45):
            heading = 3
        if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180 (i.e. upside down)
            if direction in [1, 3]:
                if direction == 1:
                    direction = 3
                elif direction == 3:
                    direction = 1
        direction = int(direction) - heading
        if direction &lt; 0:
            direction += 4
    else:                                                               # if moving along z axis
        if rotation in range(90, 181) or rotation in range(-180, -90):  # if camera is rotated around 180
            if direction == 4:                                          # switch up and down directions
                direction = 5
            elif direction == 5:
                direction = 4
    shift = SHIFT_DIRECTION[direction]                                  # get direction of shift
    # move robot
    self.selected_robot.setPos(self.render, self.selected_robot.getPos(self.render) + shift)
    # update robot position
    self.robot_pos[int(self.selected_robot.getName()[0])] = self.selected_robot.getPos(self.render)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.renderRobot"><code class="name flex">
<span>def <span class="ident">renderRobot</span></span>(<span>self, robot)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders 1 robot in the scene by iterating through its Connections</p>
<h2 id="args">Args</h2>
<p><code>robot</code>: robot object to render (Robot)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renderRobot(self, robot):
    &#34;&#34;&#34;
    Renders 1 robot in the scene by iterating through its Connections
    Args:
        `robot`: robot object to render (Robot)
    &#34;&#34;&#34;
    # add position of robot core to list (for camera focus switching)
    self.robot_pos[robot.id] = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])
    robot.connections[0].src.root = True
    # loop through connections in robot
    for i, connection in enumerate(robot.connections):
        # if src comp. is the core comp.
        if connection.src.root and i == 0:
            src_path = &#39;./models/BAM/&#39; + connection.src.type + &#39;.bam&#39;   # get path of src model file
            src = self.loader.loadModel(src_path)                       # load model of src component
            # set core&#39;s position to robot core_pos
            connection.src.pos = LVector3f(robot.core_pos[0], robot.core_pos[1], robot.core_pos[2])

            src.setPos(connection.src.pos)                              # set position of src comp.
            src.reparentTo(self.robotNode)                              # set parent to robotNode
            src.setName(str(robot.id) + connection.src.id)              # set name of node to component ID
            src.setTag(&#39;robot&#39;, str(robot.id) + connection.src.id)      # tag as selectable

            # display robot id label text
            self.displayLabel(pos=connection.src.pos, text=&#39;Robot &#39; + str(robot.id), parent=src)
            connection.src.node = src                                   # add Panda3D node to RobotComp

        dst_path = &#39;./models/BAM/&#39; + connection.dst.type + &#39;.bam&#39;       # get path of destination model file
        dst = self.loader.loadModel(dst_path)                           # load model of source component

        if not connection.standardised:                                 # if connection isn&#39;t standardised
            connection.standardiseSlots()                               # standardise slots

        dst.setName(connection.dst.id)
        dst.setTag(&#39;robot&#39;, connection.dst.id)                          # tag as selectable
        dst.setColor(connection.dst.colour)                             # set model to relevant colour

        # calc position of dest comp based on source position
        connection.dst.pos, heading = connection.dst.calcPos(src, dst, connection)

        dst.reparentTo(connection.src.node)                             # reparent dst node to src node (add to tree)

        dst.setHpr(self.render, heading, 0, 0)                          # set heading of dest. comp.
        dst.setPos(self.render, connection.dst.pos)                     # set position of dest. comp.

        # apply orientation if comp. is a hinge
        if &#39;Hinge&#39; in connection.dst.type:
            connection.dst.orientation += connection.src.orientation
            while connection.dst.orientation &gt; 3:                       # scale orientation back to 0-&gt;3
                connection.dst.orientation -= 4
            dst.setR(self.render, ORIENTATION[connection.dst.orientation])

        connection.dst.node = dst                                      # add Panda3D node to robotComp

    # add all comp. labels
    for i, connection in enumerate(robot.connections):
        node = connection.dst.node
        self.displayLabel(pos=node.getPos(self.render), text=node.getName(), parent=node)
    robot.drawBounds()
    # flatten nodes into one node per robot (performance optimisation)
    robot.connections[0].src.node.flattenStrong()
    # hide labels and set colours after flattening
    self.toggleLabels(first=True)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.reposition"><code class="name flex">
<span>def <span class="ident">reposition</span></span>(<span>self, pack_info)</span>
</code></dt>
<dd>
<div class="desc"><p>Repositions Robots and resizes environment based on the info received from the robotUtils <em>auto_pack</em> method</p>
<h2 id="args">Args</h2>
<p><code>pack_info</code>: contains positions of robots and dims of environment to fit them (Tuple)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reposition(self, pack_info):
    &#34;&#34;&#34;
    Repositions Robots and resizes environment based on the info received from the robotUtils _auto_pack_ method
    Args:
        `pack_info`: contains positions of robots and dims of environment to fit them (Tuple)
    &#34;&#34;&#34;
    positions = pack_info[0]
    self.plane.setScale(pack_info[1], pack_info[2], 10)                             # resize environment to fit all robots
    print(&#39;Resized environment to {} by {} units&#39;.format(pack_info[1], pack_info[2]))
    robots = self.robotNode.getChildren()
    # iterate through all robots in scene and reposition
    for i, robot in enumerate(robots):
        new_pos = LVector3f(positions[i][0], positions[i][1], 0)
        robot.setPos(self.render, new_pos)
        self.robot_pos[i] = new_pos                                                 # update robot position</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines which robot is selected (by mouse click), updates self.selected_robot to represent this</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self):
    &#34;&#34;&#34;Determines which robot is selected (by mouse click), updates self.selected_robot to represent this&#34;&#34;&#34;
    mpos = self.mouseWatcherNode.getMouse()
    self.pickerRay.setFromLens(self.camNode, mpos.getX(), mpos.getY())

    self.myTraverser.traverse(self.render)
    # get objects close to mouse click
    if self.myHandler.getNumEntries() &gt; 0:
        self.myHandler.sortEntries()
        pickedObj = self.myHandler.getEntry(0).getIntoNodePath()    # = closest to mouse click
        pickedObj = pickedObj.findNetTag(&#39;robot&#39;)                   # find selectable objects (pre-tagged &#39;robot&#39;)
        if not pickedObj.isEmpty():
            # if a robot was previously selected
            if hasattr(self, &#39;selected_robot&#39;):
                self.toggleBounding()                               # hide old selection box

            self.enlargeLabel(pickedObj)
            self.selected_comp = pickedObj

            # find Core comp. of robot in which the comp. is currently selected
            while True:
                if &#39;Core&#39; not in pickedObj.getName():
                    pickedObj = pickedObj.parent
                else:
                    break
            self.selected_robot = pickedObj                         # set class attribute to selected robot core
            self.toggleBounding()                                   # show new selection box
            # update selected robot and component displays
            if self.selected_robot.getName()[0].isdigit() and self.selected_robot.getName()[1].isdigit():
                sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0:2] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
            else:
                sel_text = &#39;Selected Robot: &#39; + self.selected_robot.getName()[0] + &#39;\nSelected Component: &#39; + self.selected_comp.getName()
            self.sel_textNode.setText(sel_text)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.stepNetwork"><code class="name flex">
<span>def <span class="ident">stepNetwork</span></span>(<span>self, ann, robot)</span>
</code></dt>
<dd>
<div class="desc"><p>Steps the neural network according to how much time has passed since being fed data.</p>
<p>Feeds the ANN with sensor data and starts the clock. When the output from the neural network is obtained, the time is calculated,
The robot is then stepped, which changes the positions of each of the components starting from the outwardmost output node and working toward the core component.
The change in positon for each node corresponds to the state of the node according to the neural network.</p>
<h2 id="args">Args</h2>
<p><code><a title="RoboViz.ann" href="#RoboViz.ann">ann</a></code>: the neural network/brain of the robot (ANN)<br>
<code>robot</code>: the robot the brain belongs to (Robot)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stepNetwork(self, ann, robot):
    &#34;&#34;&#34;
    Steps the neural network according to how much time has passed since being fed data.

    Feeds the ANN with sensor data and starts the clock. When the output from the neural network is obtained, the time is calculated,
    The robot is then stepped, which changes the positions of each of the components starting from the outwardmost output node and working toward the core component.
    The change in positon for each node corresponds to the state of the node according to the neural network.

    Args:
        `ann`: the neural network/brain of the robot (ANN)  
        `robot`: the robot the brain belongs to (Robot)
    &#34;&#34;&#34;
    startTime = time.time()
    ann.feed([1, 0, 1, 0, 1, 0])
    # feed the input nodes sensor data
    ann.step(startTime)
    # step the network
    out = ann.fetch()
    # fetch the outputs
    newTime = time.time() - startTime
    # time elapsed, feed this with the output nodes into robot &amp; step it
    robot.step(newTime, ann.outputPorts, out)</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.switchFocus"><code class="name flex">
<span>def <span class="ident">switchFocus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Switches camera focus (origin) between robots in scene</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchFocus(self):
    &#34;&#34;&#34;Switches camera focus (origin) between robots in scene&#34;&#34;&#34;
    while self.focus_switch_counter &gt; self.swarm_size - 1:          # loop around to start of list
        self.focus_switch_counter -= self.swarm_size
    # print(f&#39;Moving camera to robot {self.focus_switch_counter} at {list(self.robot_pos.values())[self.focus_switch_counter]}&#39;)
    self.moveCamera(pos=list(self.robot_pos.values())[self.focus_switch_counter], z_dist=800)      # move camera to next robot
    self.focus_switch_counter += 1</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.toggleBounding"><code class="name flex">
<span>def <span class="ident">toggleBounding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles visibility of robot bounding box (selection box)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleBounding(self):
    &#34;&#34;&#34;Toggles visibility of robot bounding box (selection box)&#34;&#34;&#34;
    children = self.selected_robot.getChildren()
    for child in children:
        if child.getName().split(&#39;/&#39;)[-1] == &#39;lines&#39;:               # find line node in children of root
            if child.isHidden():                                    # if bounding box is hidden
                child.show()
            else:                                                   # if bounding box is visible
                child.hide()
            break</code></pre>
</details>
</dd>
<dt id="RoboViz.Environment.toggleLabels"><code class="name flex">
<span>def <span class="ident">toggleLabels</span></span>(<span>self, first=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggles visibility of component labels</p>
<h2 id="args">Args</h2>
<p><code>first</code>: first display of labels or not (Boolean) <strong>optional</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleLabels(self, first=False):
    &#34;&#34;&#34;
    Toggles visibility of component labels
    Args:
        `first`: first display of labels or not (Boolean) **optional**  
    &#34;&#34;&#34;
    if first:
        for label in self.labels:
            label.node().setTextColor(1, 1, 1, 1)                   # set label colours after node flattening
            label.node().setCardColor(1, 1, 1, 0.3)
            label.setLightOff()                                     # remove lighting on labels
            label.hide()                                            # hide labels
    # if labels are &#39;on&#39;
    elif self.label_toggle == True:
        for label in self.labels:
            label.hide()                                            # hide labels
        self.label_toggle = False                                   # set to &#39;off&#39;
    # if labels are &#39;off&#39;
    else:
        for label in self.labels:
            label.show()                                            # show labels
        self.label_toggle = True                                    # set to &#39;on&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.Hinge"><code class="flex name class">
<span>class <span class="ident">Hinge</span></span>
<span>(</span><span>id, type, root, orientation)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an ActiveHinge or PassiveHinge component</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>id</code>: ID of Brick (String)<br>
<code>type</code>: type of brick component (String)<br>
<code>root</code>: whether this brick is the core of the robot or not (boolean)<br>
<code>orientation</code>: orientation (roll) of this component relative to its parent (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hinge(RobotComp):
    &#34;&#34;&#34;Represents an ActiveHinge or PassiveHinge component&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)
        &#34;&#34;&#34;
        super().__init__(id, type, root, orientation)
        self.colour = (0, 1, 0, 1)                      # colour of component
        self.mass = 20                                  # made up mass of component</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>roboviz.robotComp.RobotComp</li>
</ul>
</dd>
<dt id="RoboViz.Robot"><code class="flex name class">
<span>class <span class="ident">Robot</span></span>
<span>(</span><span>id, connections, components, core_pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a robot and its connections</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>id</code>: ID of robot (int)<br>
<code>connections</code>: connections between components that make up the robot (Connection[])<br>
<code>components</code>: every component in the Robot
<code>core_pos</code>: positions of the core component of the robot (int[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Robot:
    &#34;&#34;&#34;Represents a robot and its connections&#34;&#34;&#34;

    def __init__(self, id, connections, components, core_pos):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of robot (int)  
            `connections`: connections between components that make up the robot (Connection[])  
            `components`: every component in the Robot
            `core_pos`: positions of the core component of the robot (int[])
        &#34;&#34;&#34;
        self.id = id
        self.connections = connections      # list of Connections in Robot
        self.core_pos = core_pos            # position (x, y, z) of robot core component
        self.components = components        # list of RobotComps in Robot

        self.ls = LineSegs()                # for use in drawing bounding/selection box
        self.ls.setThickness(LINE_THICKNESS)
        self.ls.setColor(1, 1, 1, 1)

    def setBounds(self):
        &#34;&#34;&#34;Calculates and sets the bounds (bounding box) of the robot&#34;&#34;&#34;
        root_node = self.connections[0].src.node                            # get root node

        robot_min, robot_max = root_node.getTightBounds()                   # root node bounds
        box = BoundingBox(robot_min, robot_max)
        vertices = box.getPoints()                                          # get 8 corners of bounding box

        # calc bounds of robot bounding box
        x_max, x_min, y_max, y_min, z_max, z_min = vertices[4][0], vertices[0][0], vertices[2][1], vertices[0][1], vertices[1][2], vertices[2][2]
        self.bounds = [x_max, x_min, y_max, y_min, z_max, z_min]            # set bounds of robot

    def drawBounds(self):
        &#34;&#34;&#34;Draws LineSegs between all points of the robot bounding box&#34;&#34;&#34;
        root_node = self.connections[0].src.node                            # get root node
        robot_min, robot_max = root_node.getTightBounds(root_node)          # get bounds of whole robot
        box = BoundingBox(robot_min, robot_max)
        vertices = box.getPoints()                                          # get points of robot bounding box

        # draw &#39;side&#39; parts of selection box
        for z in range(0, len(vertices), 4):
            self.ls.moveTo(vertices[z])
            self.ls.drawTo(vertices[z + 1])
            self.ls.drawTo(vertices[z + 3])
            self.ls.drawTo(vertices[z + 2])
            self.ls.drawTo(vertices[z])

        # draw &#39;top and bottom&#39; parts of selection box
        for xy in range(0, len(vertices)//2):
            self.ls.moveTo(vertices[xy])
            self.ls.drawTo(vertices[xy + len(vertices)//2])

        bounds_node = self.ls.create()
        self.bounding_box = NodePath(bounds_node)
        self.bounding_box.reparentTo(root_node)                             # reparent bounding box to robot root
        self.bounding_box.hide()                                            # hide bounding box

    def outOfBoundsDetect(self, x_length, y_length, test=False):
        &#34;&#34;&#34;
        Determines if robot exceeds the dimensions of the environment
        Args:
            `x_length`: x length of the environment (int)  
            `y_length`: y length of the environment (int)  
            `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
        Returns:
            `out_of_bounds`: x and y values of how far the robot is out of bounds (LVector3f), returns `&#39;none&#39;` if not out of bounds
        &#34;&#34;&#34;
        if not test:
            self.setBounds()                                                # calc &amp; set bounds of robot
        out_of_bounds = LVector2f(0, 0)
        if self.bounds[0] &gt; x_length/2:                                     # if over +x edge
            out_of_bounds[0] = int(self.bounds[0] - x_length/2)
        elif self.bounds[1] &lt; -x_length/2:                                  # if over -x edge
            out_of_bounds[0] = int(x_length/2 + self.bounds[1])
        if self.bounds[2] &gt; y_length/2:                                     # if over +y edge
            out_of_bounds[1] = int(self.bounds[2] - y_length/2)
        elif self.bounds[3] &lt; -y_length/2:                                  # if over -y edge
            out_of_bounds[1] = int(y_length/2 + self.bounds[3])
        if out_of_bounds != LVector2f(0, 0):                                # if out of bounds detected
            return out_of_bounds
        else:
            return &#39;none&#39;                                                   # if no out of bounds detected

    def step(self, time, nodes, states):
        &#34;&#34;&#34;
        As the neural network is stepped, the robot components are stepped to update their positions.

        Calculates the change in position of each component according to the output of the output neurons.
        Resets the positions of all the components in the robot accordingly.

        Args:
            `time`: amount of time elapsed since the neural network was fed with data (float)  
            `nodes`: array of output nodes in the ann (RobotComp[])  
            `states`: array of output data from the output ports (double[])
        &#34;&#34;&#34;
        # step the robot
        count = len(states)-1
        # counts the position in the state array
        for comp in reversed(self.components):
            # count backwards
            for n in nodes:
                if comp == n:
                    # find the output node
                    a = comp.calcAccelaration()
                    # calculate the accelaration from the weight &amp; gravity
                    # multiply the accelaration by the output of the ann
                    comp.deltaX = 0.5*a*time*time*states[count]
                    # the states array and node array should correspond in position
                    # iterate backward to avoid having to traverse entire array of components before finding output ports
                    count = count-1
                    # calculate the change in distance
                    comp.pos = comp.pos+comp.deltaX
                    # change the destination of the component
            if comp not in nodes:
                # if not an output node
                a = comp.calcAccelaration()
                # calculate the accelaration
                comp.deltaX = 0.5 * a * time * time
                # calculate the change in distance from the acceleration
                # find the destination component &amp; get that deltaX
                for connection in self.connections:
                    if comp == connection.src:
                        comp.deltaX = comp.deltaX*(connection.src.deltaX*0.1)
                        # reduce the affect of the destination component&#39;s deltaX on the src component&#39;s deltaX by a factor of 10%
                comp.pos = comp.pos+comp.deltaX
                # update the position of the components
                # calculate acceleration but only change position by smaller and smaller as goes to core

    def __str__(self):
        &#34;&#34;&#34;
        toString for Robot object
        Returns:
            `s`: Robot in String form (String)
        &#34;&#34;&#34;
        count = 0
        s = f&#34;ID: {self.id}, Connections: &#34;
        for i in self.connections:
            s = s + f&#34;\n{count+1}: {i}&#34;
            count = count+1
        s = s + f&#34;\nCore: {self.core_pos}&#34;
        s = s+f&#34;\nTotal connections: {count}&#34;
        return s</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.Robot.drawBounds"><code class="name flex">
<span>def <span class="ident">drawBounds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws LineSegs between all points of the robot bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawBounds(self):
    &#34;&#34;&#34;Draws LineSegs between all points of the robot bounding box&#34;&#34;&#34;
    root_node = self.connections[0].src.node                            # get root node
    robot_min, robot_max = root_node.getTightBounds(root_node)          # get bounds of whole robot
    box = BoundingBox(robot_min, robot_max)
    vertices = box.getPoints()                                          # get points of robot bounding box

    # draw &#39;side&#39; parts of selection box
    for z in range(0, len(vertices), 4):
        self.ls.moveTo(vertices[z])
        self.ls.drawTo(vertices[z + 1])
        self.ls.drawTo(vertices[z + 3])
        self.ls.drawTo(vertices[z + 2])
        self.ls.drawTo(vertices[z])

    # draw &#39;top and bottom&#39; parts of selection box
    for xy in range(0, len(vertices)//2):
        self.ls.moveTo(vertices[xy])
        self.ls.drawTo(vertices[xy + len(vertices)//2])

    bounds_node = self.ls.create()
    self.bounding_box = NodePath(bounds_node)
    self.bounding_box.reparentTo(root_node)                             # reparent bounding box to robot root
    self.bounding_box.hide()                                            # hide bounding box</code></pre>
</details>
</dd>
<dt id="RoboViz.Robot.outOfBoundsDetect"><code class="name flex">
<span>def <span class="ident">outOfBoundsDetect</span></span>(<span>self, x_length, y_length, test=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if robot exceeds the dimensions of the environment</p>
<h2 id="args">Args</h2>
<p><code>x_length</code>: x length of the environment (int)<br>
<code>y_length</code>: y length of the environment (int)<br>
<code>test</code>: whether method is being tested or not (boolean) <strong>optional</strong>, only used when called from <em>test_method.py</em></p>
<h2 id="returns">Returns</h2>
<p><code>out_of_bounds</code>: x and y values of how far the robot is out of bounds (LVector3f), returns <code>'none'</code> if not out of bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outOfBoundsDetect(self, x_length, y_length, test=False):
    &#34;&#34;&#34;
    Determines if robot exceeds the dimensions of the environment
    Args:
        `x_length`: x length of the environment (int)  
        `y_length`: y length of the environment (int)  
        `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
    Returns:
        `out_of_bounds`: x and y values of how far the robot is out of bounds (LVector3f), returns `&#39;none&#39;` if not out of bounds
    &#34;&#34;&#34;
    if not test:
        self.setBounds()                                                # calc &amp; set bounds of robot
    out_of_bounds = LVector2f(0, 0)
    if self.bounds[0] &gt; x_length/2:                                     # if over +x edge
        out_of_bounds[0] = int(self.bounds[0] - x_length/2)
    elif self.bounds[1] &lt; -x_length/2:                                  # if over -x edge
        out_of_bounds[0] = int(x_length/2 + self.bounds[1])
    if self.bounds[2] &gt; y_length/2:                                     # if over +y edge
        out_of_bounds[1] = int(self.bounds[2] - y_length/2)
    elif self.bounds[3] &lt; -y_length/2:                                  # if over -y edge
        out_of_bounds[1] = int(y_length/2 + self.bounds[3])
    if out_of_bounds != LVector2f(0, 0):                                # if out of bounds detected
        return out_of_bounds
    else:
        return &#39;none&#39;                                                   # if no out of bounds detected</code></pre>
</details>
</dd>
<dt id="RoboViz.Robot.setBounds"><code class="name flex">
<span>def <span class="ident">setBounds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates and sets the bounds (bounding box) of the robot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBounds(self):
    &#34;&#34;&#34;Calculates and sets the bounds (bounding box) of the robot&#34;&#34;&#34;
    root_node = self.connections[0].src.node                            # get root node

    robot_min, robot_max = root_node.getTightBounds()                   # root node bounds
    box = BoundingBox(robot_min, robot_max)
    vertices = box.getPoints()                                          # get 8 corners of bounding box

    # calc bounds of robot bounding box
    x_max, x_min, y_max, y_min, z_max, z_min = vertices[4][0], vertices[0][0], vertices[2][1], vertices[0][1], vertices[1][2], vertices[2][2]
    self.bounds = [x_max, x_min, y_max, y_min, z_max, z_min]            # set bounds of robot</code></pre>
</details>
</dd>
<dt id="RoboViz.Robot.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, time, nodes, states)</span>
</code></dt>
<dd>
<div class="desc"><p>As the neural network is stepped, the robot components are stepped to update their positions.</p>
<p>Calculates the change in position of each component according to the output of the output neurons.
Resets the positions of all the components in the robot accordingly.</p>
<h2 id="args">Args</h2>
<p><code>time</code>: amount of time elapsed since the neural network was fed with data (float)<br>
<code>nodes</code>: array of output nodes in the ann (RobotComp[])<br>
<code>states</code>: array of output data from the output ports (double[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, time, nodes, states):
    &#34;&#34;&#34;
    As the neural network is stepped, the robot components are stepped to update their positions.

    Calculates the change in position of each component according to the output of the output neurons.
    Resets the positions of all the components in the robot accordingly.

    Args:
        `time`: amount of time elapsed since the neural network was fed with data (float)  
        `nodes`: array of output nodes in the ann (RobotComp[])  
        `states`: array of output data from the output ports (double[])
    &#34;&#34;&#34;
    # step the robot
    count = len(states)-1
    # counts the position in the state array
    for comp in reversed(self.components):
        # count backwards
        for n in nodes:
            if comp == n:
                # find the output node
                a = comp.calcAccelaration()
                # calculate the accelaration from the weight &amp; gravity
                # multiply the accelaration by the output of the ann
                comp.deltaX = 0.5*a*time*time*states[count]
                # the states array and node array should correspond in position
                # iterate backward to avoid having to traverse entire array of components before finding output ports
                count = count-1
                # calculate the change in distance
                comp.pos = comp.pos+comp.deltaX
                # change the destination of the component
        if comp not in nodes:
            # if not an output node
            a = comp.calcAccelaration()
            # calculate the accelaration
            comp.deltaX = 0.5 * a * time * time
            # calculate the change in distance from the acceleration
            # find the destination component &amp; get that deltaX
            for connection in self.connections:
                if comp == connection.src:
                    comp.deltaX = comp.deltaX*(connection.src.deltaX*0.1)
                    # reduce the affect of the destination component&#39;s deltaX on the src component&#39;s deltaX by a factor of 10%
            comp.pos = comp.pos+comp.deltaX
            # update the position of the components
            # calculate acceleration but only change position by smaller and smaller as goes to core</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.RobotComp"><code class="flex name class">
<span>class <span class="ident">RobotComp</span></span>
<span>(</span><span>id, type, root, orientation)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a component of a robot</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>id</code>: ID of Brick (String)<br>
<code>type</code>: type of brick component (String)<br>
<code>root</code>: whether this brick is the core of the robot or not (boolean)<br>
<code>orientation</code>: orientation (roll) of this component relative to its parent (int)<br>
<code>deltaX</code>: the amount by which the component's destination is offset when the neural network is being fed (double)<br>
<code>mass</code>: the mass of the component, determined by whether it is a brick or a hinge (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RobotComp:
    &#34;&#34;&#34;Represents a component of a robot&#34;&#34;&#34;

    def __init__(self, id, type, root, orientation):
        &#34;&#34;&#34;
        Constructor
        Args:
            `id`: ID of Brick (String)  
            `type`: type of brick component (String)  
            `root`: whether this brick is the core of the robot or not (boolean)  
            `orientation`: orientation (roll) of this component relative to its parent (int)  
            `deltaX`: the amount by which the component&#39;s destination is offset when the neural network is being fed (double)  
            `mass`: the mass of the component, determined by whether it is a brick or a hinge (int)
        &#34;&#34;&#34;
        self.id = id
        self.type = type                # component type
        self.root = root                # component is the root of the robot component tree
        self.orientation = orientation  # global orientation
        self.direction = 0              # global heading
        self.deltaX = 0

    def calcPos(self, src, dst, connection, test=False):
        &#34;&#34;&#34;
        Calculates the position that the component should be placed at in the scene based on the source&#39;s position
        Args:
            `src`: source Panda3D node in connection (PandaNode)  
            `dst`: destination Panda3D node in connection (PandaNode)  
            `connection`: the Connection in question (Connection)  
            `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
        Returns:
            `(dst_pos, heading)`: position and heading that component should be placed at in the scene (LVector3f, int)
        &#34;&#34;&#34;
        if not test:
            connection.dst.bounds = dst.getTightBounds()

        # only get new bounds for src comp. if it&#39;s the &#39;root&#39; comp. Otherwise just use connection.src.bounds
        if connection.src.root == True and not test:
            connection.src.bounds = src.getTightBounds()
            connection.src.root = False

        src_min, src_max = connection.src.bounds[0], connection.src.bounds[1]
        src_dims = (src_max - src_min)/2                                        # get distance from centre of source model to edge
        src_pos = connection.src.pos

        # if hinge connected to a brick, use buffer to &#39;slot&#39; together cleanly (otherwise leaves an awkward space)
        if connection.dst.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;] or connection.src.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;]:
            src_dims -= BUFFER

        dst_min, dst_max = connection.dst.bounds[0], connection.dst.bounds[1]
        dst_dims = (dst_max - dst_min)/2                                        # get distance from centre of dest model to edge

        src_slot = connection.src_slot - connection.src.direction               # get slot number relative to direction of src comp. (&#39;global&#39; slot number)
        if src_slot &lt; 0:                                                        # wrap slots around (-1=3 etc.)
            src_slot += 4

        heading = SRC_SLOTS[src_slot] + DST_SLOTS[connection.dst_slot]          # heading of dst model, dependent on src and dst slot
        connection.dst.direction = DIRECTION[heading]

        # which dims to use to calculate new pos (x or y)
        if connection.src_slot in [0, 2]:
            src_dim = src_dims[1]
        else:
            src_dim = src_dims[0]
        if connection.dst_slot in [0, 2]:
            dst_dim = dst_dims[1]
        else:
            dst_dim = dst_dims[0]

        # use src slot to determine which side of src comp. to place dest comp. on
        # LVector3f(x, y, z)
        if src_slot == 0:
            dst_pos = src_pos + LVector3f(0, -(src_dim + dst_dim), 0)           # -y (bottom)
        elif src_slot == 1:
            dst_pos = src_pos + LVector3f(-(src_dim + dst_dim), 0, 0)           # -x (left)
        elif src_slot == 2:
            dst_pos = src_pos + LVector3f(0, src_dim + dst_dim, 0)              # +y (top)
        elif src_slot == 3:
            dst_pos = src_pos + LVector3f(src_dim + dst_dim, 0, 0)              # +x (right)
        return (dst_pos, heading)

    def calcAcceleration(self):
        &#34;&#34;&#34;
        Calculates the accelaration of the component with regards to its mass and gravity
        Returns:
            `a`: the accelaration (double)
        &#34;&#34;&#34;
        a = self.mass*9.8
        return a

    def as_dict(self):
        &#34;&#34;&#34;
        Represents a RobotComp object as a dictionary, for use in the RobotUtils **writeRobot** method
        Returns:
            `dict`: contains all RobotComp fields as a dict
        &#34;&#34;&#34;
        dict = {}
        dict[&#39;id&#39;] = self.id
        dict[&#39;type&#39;] = self.type
        dict[&#39;root&#39;] = self.root
        dict[&#39;orientation&#39;] = self.orientation
        return dict

    def __str__(self):
        &#34;&#34;&#34;
        toString for RobotComp object
        Returns:
            RobotComp in String form (String)
        &#34;&#34;&#34;
        return f&#34;ID: {self.id}, Type: {self.type}, root: {self.root}, orient: {self.orientation}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.RobotComp.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a RobotComp object as a dictionary, for use in the RobotUtils <strong>writeRobot</strong> method</p>
<h2 id="returns">Returns</h2>
<p><code>dict</code>: contains all RobotComp fields as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self):
    &#34;&#34;&#34;
    Represents a RobotComp object as a dictionary, for use in the RobotUtils **writeRobot** method
    Returns:
        `dict`: contains all RobotComp fields as a dict
    &#34;&#34;&#34;
    dict = {}
    dict[&#39;id&#39;] = self.id
    dict[&#39;type&#39;] = self.type
    dict[&#39;root&#39;] = self.root
    dict[&#39;orientation&#39;] = self.orientation
    return dict</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotComp.calcAcceleration"><code class="name flex">
<span>def <span class="ident">calcAcceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the accelaration of the component with regards to its mass and gravity</p>
<h2 id="returns">Returns</h2>
<p><code>a</code>: the accelaration (double)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcAcceleration(self):
    &#34;&#34;&#34;
    Calculates the accelaration of the component with regards to its mass and gravity
    Returns:
        `a`: the accelaration (double)
    &#34;&#34;&#34;
    a = self.mass*9.8
    return a</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotComp.calcPos"><code class="name flex">
<span>def <span class="ident">calcPos</span></span>(<span>self, src, dst, connection, test=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the position that the component should be placed at in the scene based on the source's position</p>
<h2 id="args">Args</h2>
<p><code>src</code>: source Panda3D node in connection (PandaNode)<br>
<code>dst</code>: destination Panda3D node in connection (PandaNode)<br>
<code>connection</code>: the Connection in question (Connection)<br>
<code>test</code>: whether method is being tested or not (boolean) <strong>optional</strong>, only used when called from <em>test_method.py</em></p>
<h2 id="returns">Returns</h2>
<p><code>(dst_pos, heading)</code>: position and heading that component should be placed at in the scene (LVector3f, int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcPos(self, src, dst, connection, test=False):
    &#34;&#34;&#34;
    Calculates the position that the component should be placed at in the scene based on the source&#39;s position
    Args:
        `src`: source Panda3D node in connection (PandaNode)  
        `dst`: destination Panda3D node in connection (PandaNode)  
        `connection`: the Connection in question (Connection)  
        `test`: whether method is being tested or not (boolean) **optional**, only used when called from _test_method.py_
    Returns:
        `(dst_pos, heading)`: position and heading that component should be placed at in the scene (LVector3f, int)
    &#34;&#34;&#34;
    if not test:
        connection.dst.bounds = dst.getTightBounds()

    # only get new bounds for src comp. if it&#39;s the &#39;root&#39; comp. Otherwise just use connection.src.bounds
    if connection.src.root == True and not test:
        connection.src.bounds = src.getTightBounds()
        connection.src.root = False

    src_min, src_max = connection.src.bounds[0], connection.src.bounds[1]
    src_dims = (src_max - src_min)/2                                        # get distance from centre of source model to edge
    src_pos = connection.src.pos

    # if hinge connected to a brick, use buffer to &#39;slot&#39; together cleanly (otherwise leaves an awkward space)
    if connection.dst.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;] or connection.src.type in [&#39;FixedBrick&#39;, &#39;CoreComponent&#39;]:
        src_dims -= BUFFER

    dst_min, dst_max = connection.dst.bounds[0], connection.dst.bounds[1]
    dst_dims = (dst_max - dst_min)/2                                        # get distance from centre of dest model to edge

    src_slot = connection.src_slot - connection.src.direction               # get slot number relative to direction of src comp. (&#39;global&#39; slot number)
    if src_slot &lt; 0:                                                        # wrap slots around (-1=3 etc.)
        src_slot += 4

    heading = SRC_SLOTS[src_slot] + DST_SLOTS[connection.dst_slot]          # heading of dst model, dependent on src and dst slot
    connection.dst.direction = DIRECTION[heading]

    # which dims to use to calculate new pos (x or y)
    if connection.src_slot in [0, 2]:
        src_dim = src_dims[1]
    else:
        src_dim = src_dims[0]
    if connection.dst_slot in [0, 2]:
        dst_dim = dst_dims[1]
    else:
        dst_dim = dst_dims[0]

    # use src slot to determine which side of src comp. to place dest comp. on
    # LVector3f(x, y, z)
    if src_slot == 0:
        dst_pos = src_pos + LVector3f(0, -(src_dim + dst_dim), 0)           # -y (bottom)
    elif src_slot == 1:
        dst_pos = src_pos + LVector3f(-(src_dim + dst_dim), 0, 0)           # -x (left)
    elif src_slot == 2:
        dst_pos = src_pos + LVector3f(0, src_dim + dst_dim, 0)              # +y (top)
    elif src_slot == 3:
        dst_pos = src_pos + LVector3f(src_dim + dst_dim, 0, 0)              # +x (right)
    return (dst_pos, heading)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.RobotGUI"><code class="flex name class">
<span>class <span class="ident">RobotGUI</span></span>
<span>(</span><span>config_path='', pos_path='', robot_path='', cli=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialises the GUI for inputting files, building robots and reporting errors</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>config_path</code>: file path of configuration text file (String) <strong>optional</strong>, only used when building a robot<br>
<code>pos_path</code>: file path of robot positions text file (String) <strong>optional</strong>, only used when building a robot<br>
<code>robot_path</code>: file path of robot JSON file (String) <strong>optional</strong>, only used when building a robot
<code>cli</code>: whether or not the program is running in CLI mode (boolean) <strong>optional</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RobotGUI:
    &#34;&#34;&#34;Initialises the GUI for inputting files, building robots and reporting errors&#34;&#34;&#34;

    def __init__(self, config_path=&#39;&#39;, pos_path=&#39;&#39;, robot_path=&#39;&#39;, cli=False):
        &#34;&#34;&#34;
        Constructor
        Args:
            `config_path`: file path of configuration text file (String) **optional**, only used when building a robot  
            `pos_path`: file path of robot positions text file (String) **optional**, only used when building a robot  
            `robot_path`: file path of robot JSON file (String) **optional**, only used when building a robot
            `cli`: whether or not the program is running in CLI mode (boolean) **optional**
        &#34;&#34;&#34;
        self.config_path = config_path
        self.pos_path = pos_path
        self.robot_path = robot_path
        self.working_directory = os.getcwd()
        self.out_of_bounds_all = []
        self.collisions = []
        self.cli = cli
        self.utils = RobotUtils(self.config_path, self.pos_path, self.robot_path)
        self.bgColour = &#34;Black&#34;

    def help_window(self, type):
        &#34;&#34;&#34;
        Displays the help window
        Args:
            `type`: type of help info to display (file or build), (String)
        &#34;&#34;&#34;
        # help in main GUI (loading from file)
        if type == &#39;file&#39;:
            help = &#34;To load a robot:\n  * browse for and choose a configuration, robot positions, and robot JSON file\n  * click on the &#39;Submit&#39; button to start the simulation\n(file formats are available in &#39;./docs/User_Manual.md&#39; under Appendix: File Formats)\n\nTo use auto-pack:\n  * toggle the &#39;auto-pack&#39; check box\n  * browse for and choose a configuration and robot JSON file\n  * click on the &#39;Submit&#39; button\n(positions will be automatically calculated and environment will be resized if needed)\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
        # help in build GUI (building a custom robot)
        elif type == &#39;build&#39;:
            help = &#34;To add a component:\n  * click the desired parent component in the tree\n  * select the desired type of component from the dropdown\n  * give the component an ID in the text box (&#39;comp_id&#39;)\n  * click the &#39;+&#39; button and fill in the source &amp; destination slots and orientation\n  * click on the &#39;Submit&#39; button to start the simulation\n\nTo load a robot from a JSON file click on the &#39;Browse&#39; button and select a robot JSON file\n\nBuilt robots can also be saved by checking &#39;Write to file&#39;, giving it a name and clicking &#39;Submit&#39;\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
        layout = [[sg.Multiline(default_text=help, disabled=True, size=(70, 15), no_scrollbar=True)],
                  [sg.Button(&#39;Ok&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#39;Help&#39;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, _ = window.read()
            if event == sg.WIN_CLOSED or event == &#39;Ok&#39;:
                break
        window.close()

    def error_window(self):
        &#34;&#34;&#34;Displays the error reporting window&#34;&#34;&#34;
        if len(self.collisions) &gt; 0:
            # format robot collisions
            collision_text = formatCollisions(self.collisions)
            if len(self.out_of_bounds_all) &gt; 0:
                # format out of bounds errors
                out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
                # collisions and out of bounds
                layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
            else:
                # only collisions
                layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                          [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                          [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
        elif len(self.out_of_bounds_all) &gt; 0:
            out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
            # only out of bounds
            layout = [[sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                      [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                      [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]

        sg.theme(self.bgColour)
        window = sg.Window(&#34;Errors&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, _ = window.read()
            if event == &#34;Continue&#34; or event == sg.WIN_CLOSED:
                # continue with program
                break
            if event == &#34;Cancel&#34;:
                # quit if user clicks cancel
                quit()

        window.close()

    def connection_window(self):
        &#34;&#34;&#34;
        Displays the component connection window for specifying specific connection parameters
        Returns:
            `(src_slot, dst_slot, orientation)`: source, dest slots + orientation of component ((int, int, int)) (returns (-1, -1, -1) if window closed)
        &#34;&#34;&#34;
        layout = [[sg.Text(&#39;SRC Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-SRC_COMBO-&#39;)],
                  [sg.Text(&#39;DST Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-DST_COMBO-&#39;)],
                  [sg.Text(&#39;Orientation:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-O_COMBO-&#39;)],
                  [sg.Button(&#39;Submit&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#34;Enter Slots&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, values = window.read()
            if event == sg.WIN_CLOSED:
                window.close()
                return (-1, -1, -1)     # if user closes without entering anything, return (-1, -1, -1)
            if event == &#39;Submit&#39;:
                window.close()
                # return src_slot, dst_slot and orientation
                return (values[&#39;-SRC_COMBO-&#39;], values[&#39;-DST_COMBO-&#39;], values[&#39;-O_COMBO-&#39;])

    def build_window(self):
        &#34;&#34;&#34;Displays the Robot building window&#34;&#34;&#34;
        components = []
        connections = []
        treedata = sg.TreeData()

        # place core component in tree first
        core = Brick(&#39;Core&#39;, &#39;CoreComponent&#39;, True, 0)
        components.append(core)
        treedata.insert(parent=&#39;&#39;, key=core.id, text=core.id, values=[&#39;CoreComponent&#39;, core.orientation])
        # create UI layout
        layout = [[sg.Button(&#39;+&#39;, size=3, tooltip=&#39;add component&#39;), sg.Combo(values=COMPONENTS, default_value=COMPONENTS[0], key=&#39;-C_COMBO-&#39;, tooltip=&#39;component type&#39;),
                   sg.InputText(key=&#39;-COMP_ID-&#39;, size=30, default_text=&#39;comp_id&#39;)],
                  [sg.Text(&#39;Components&#39;)],
                  [sg.Tree(data=treedata, key=&#34;-COMP_TREE-&#34;, auto_size_columns=True, num_rows=20, headings=[&#39;Type&#39;, &#39;Orientation&#39;], col0_width=30, expand_x=True, show_expanded=True), ],
                  [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(&#39;Back&#39;, tooltip=&#39;return to file menu&#39;), sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)], target=&#39;-LOAD-&#39;, tooltip=&#39;load robot JSON&#39;),
                  sg.Input(key=&#39;-LOAD-&#39;, enable_events=True, visible=False), sg.Checkbox(&#39;Write to file&#39;, default=True, key=&#39;-FILE-&#39;, tooltip=&#39;write robot to JSON&#39;),
                  sg.InputText(key=&#39;-F_NAME-&#39;, size=30, default_text=&#39;robot_name&#39;)]]
        sg.theme(self.bgColour)
        window = sg.Window(&#34;Build a Robot&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
        while True:
            event, values = window.read()
            if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
                quit()
            if event == &#39;Back&#39;:
                # return to file menu
                break
            if event == &#39;Help&#39;:
                # show help window
                self.help_window(&#39;build&#39;)
            if event == &#39;-LOAD-&#39;:
                # user loads a JSON file from drive
                if values[&#39;-LOAD-&#39;] == &#39;&#39;:
                    # if no file selected
                    continue
                self.utils.robot_path = values[&#39;-LOAD-&#39;]
                # parse robot in from chosen file
                robot = self.utils.robotParse(1, [[0, 0, 0]], build=True)[0]
                for connection in robot.connections:
                    dst = connection.dst
                    # append components to the tree
                    treedata.Insert(parent=connection.src.id, key=dst.id, text=dst.id, values=[dst.type, dst.orientation])
                window.Element(&#39;-COMP_TREE-&#39;).update(treedata)
                components = robot.components
                connections = robot.connections

            if event == &#39;+&#39;:
                # add new component
                if values[&#39;-COMP_ID-&#39;] in treedata.tree_dict:
                    # if component id already exists in tree
                    sg.popup(&#34;Component {} already exists&#34;.format(values[&#39;-COMP_ID-&#39;]))
                    continue
                if &#39; &#39; in values[&#39;-COMP_ID-&#39;]:
                    # if component name contains spaces
                    sg.popup(&#34;No spaces in component ID&#34;)
                    continue
                if len(values[&#39;-COMP_TREE-&#39;]) == 0:
                    # if nothing selected, continue
                    sg.popup(&#34;Please select a component&#34;)
                    continue
                else:
                    sel_comp = values[&#39;-COMP_TREE-&#39;][0]

                id = values[&#39;-COMP_ID-&#39;]
                type = values[&#39;-C_COMBO-&#39;]
                # open connection window to choose slots and orientation
                src_slot, dst_slot, orientation = self.connection_window()
                # find parent in component list
                parent = next(comp for comp in components if comp.id == sel_comp)

                if src_slot == -1 or dst_slot == -1 or orientation == -1:
                    # if user exited window
                    continue
                if &#39;Hinge&#39; in parent.type:
                    # invalid src slot for hinge
                    if src_slot in [2, 3]:
                        sg.popup(&#34;Invalid source slot for Hinge&#34;)
                        continue
                if &#39;Hinge&#39; in type:
                    # invalid dst slot for hinge
                    if dst_slot in [2, 3]:
                        sg.popup(&#34;Invalid destination slot for Hinge&#34;)
                        continue
                    comp = Hinge(id, type, False, orientation)
                else:
                    comp = Brick(id, type, False, orientation)

                treedata.Insert(parent=sel_comp, key=id, text=id, values=[type, orientation])   # insert new node
                window.Element(&#39;-COMP_TREE-&#39;).update(treedata)

                components.append(comp)
                connections.append(Connection(parent, comp, src_slot, dst_slot))

            if event == &#39;Submit&#39;:
                if len(components) == 1:
                    # if only core comp. in tree
                    sg.popup(&#34;Please add more than one component&#34;)
                    continue
                if &#39; &#39; in values[&#39;-F_NAME-&#39;]:
                    # if file name contains spaces
                    sg.popup(&#34;No spaces in file name&#34;)
                    continue
                robot = Robot(0, connections, components, [0, 0, 0])
                config = [1000, 1000, 1]                                # default config for 1 robot
                if (values[&#39;-FILE-&#39;]):
                    self.utils.writeRobot(robot, values[&#39;-F_NAME-&#39;])    # write custom robot to JSON file
                window.hide()
                self.runSim(config=config, robots=[robot], build=True)  # run environment simulation with custom robot
                window.UnHide()

        window.close()

    def startGUI(self):
        &#34;&#34;&#34;Displays the file input GUI window&#34;&#34;&#34;

        LastRender = False
        # errors for file IO
        configError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
        posError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
        jsonError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)

        if(not exists(&#39;LastRender.txt&#39;)):
            # layout for if no previous file paths are found
            layout = [
                [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
                [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
                [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
                [sg.InputText(key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
                [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                    &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
            ]
        else:
            # if previous file paths found, read in and place in file path text boxes
            LastRender = True
            pos_path = &#34;&#34;
            config_path = &#34;&#34;
            robot_path = &#34;&#34;
            with open(&#39;LastRender.txt&#39;, &#39;r&#39;) as f:
                i = 0
                for line in f:
                    line = line.strip()
                    if i == 0:
                        pos_path = line
                    elif i == 1:
                        config_path = line
                    elif i == 2:
                        robot_path = line
                    i += 1
            layout = [
                [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=config_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
                [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=pos_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
                [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
                [sg.InputText(default_text=robot_path, key=&#34;-FILE_PATH-&#34;),
                 sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
                [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                    &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
            ]

        sg.theme(self.bgColour)
        window = sg.Window(&#34;RoboViz&#34;, layout, icon=&#39;resources/r_icon.ico&#39;)

        # Main Program Loop
        while True:
            auto_pack = False
            event, values = window.read()

            if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
                break

            elif (event == &#34;Help&#34;):
                # show help window
                self.help_window(&#39;file&#39;)

            elif (event == &#34;Build&#34;):
                # switch to build window and hide file window
                window.hide()
                self.build_window()
                window.UnHide()

            # show file IO errors if a file is left out
            elif (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] == &#34;&#34;):
                configError.update(value=&#34;Configuration file not included&#34;, visible=True)
            else:
                configError.update(visible=False)

            if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-0&#34;] == &#34;&#34; and not values[&#39;-A_PACK-&#39;]):
                posError.update(value=&#34;Positions file not included&#34;, visible=True)
            else:
                posError.update(visible=False)

            if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-2&#34;] == &#34;&#34;):
                jsonError.update(value=&#34;Robots file not included&#34;, visible=True)
            else:
                jsonError.update(visible=False)

            # if all file paths given OR if config and robot paths given and auto-pack enabled (positions not required)
            if ((event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-0&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-2&#34;] != &#34;&#34;) or (event == &#39;Submit&#39; and values[&#39;-A_PACK-&#39;])):
                if values[&#39;-A_PACK-&#39;]:
                    auto_pack = True
                self.config_path = values[&#34;-FILE_PATH-&#34;]
                self.pos_path = values[&#34;-FILE_PATH-0&#34;]
                self.robot_path = values[&#34;-FILE_PATH-2&#34;]

                # GUI parsing and error checking
                self.utils = RobotUtils(self.config_path, self.pos_path, self.robot_path)
                # config parsing #
                config = self.utils.configParse()
                if not config:
                    configError.update(value=&#34;Incorrect configuration file format&#34;, visible=True)
                    continue
                else:
                    configError.update(visible=False)
                if not auto_pack:
                    # positions parsing #
                    positions = self.utils.posParse()
                    if not positions:
                        posError.update(value=&#34;Incorrect positions file format&#34;, visible=True)
                        continue
                    else:
                        posError.update(visible=False)
                else:
                    # default positions for auto-pack to use
                    positions = [[0, 0, 0]]*int(config[2])
                # robots parsing #
                robots = self.utils.robotParse(int(config[2]), positions)
                if not robots:
                    jsonError.update(value=&#34;Incorrect robot file format&#34;, visible=True)
                    continue
                elif robots == True:
                    posError.update(value=&#34;Incorrect amount of robot positions given&#34;, visible=True)
                    continue
                else:
                    jsonError.update(visible=False)
                # num. of robots in robot file do not match swarm size in config file
                if len(robots) != config[2]:
                    configError.update(value=&#34;Mismatch between swarm size and number of robots given&#34;, visible=True)
                    continue
                # num. of positions in positions file do not match swarm size in config file
                if len(positions) != config[2]:
                    posError.update(value=&#34;Mismatch between number of positions and swarm size given&#34;, visible=True)
                    continue

                # write chosen file paths to file
                lines = [self.pos_path, self.config_path, self.robot_path]
                with open(&#39;LastRender.txt&#39;, &#39;w&#39;) as f:
                    for line in lines:
                        f.write(line)
                        f.write(&#39; \n&#39;)

                window.hide()                                       # hide GUI window
                self.runSim(config, robots, auto_pack=auto_pack)    # start simulation (Panda)
                window.UnHide()                                     # show GUI window again after exiting Panda

        window.close()

    def runSim(self, config=&#39;&#39;, robots=&#39;&#39;, auto_pack=False, build=False):
        &#34;&#34;&#34;
        Creates the Environment and runs the simulation
        Args:
            `auto_pack`: whether the packing algorithm will be used to auto-position the robots (Boolean) **optional**  
            `config`: configuration parameters (int[]) **optional**, only used when building a robot  **optional**  
            `robots`: array of Robots (Robot[]) **optional**, only used when building a robot  **optional**  
            `build`: whether or not simulation is being run from robot builder (boolean) **optional**
        &#34;&#34;&#34;
        # CLI parsing and error checking
        if self.cli:
            # config parsing #
            config = self.utils.configParse()
            if not config:
                print(&#34;[ERROR] Incorrect configuration file format or file not found&#34;)
                quit()

            # positions parsing #
            positions = self.utils.posParse()
            if not positions:
                print(&#34;[ERROR] Incorrect positions file format or file not found&#34;)
                quit()

            # robot parsing #
            robots = self.utils.robotParse(int(config[2]), positions)
            if not robots:
                print(&#34;[ERROR] Incorrect robot file format or file not found&#34;)
                quit()
            elif robots == True:
                print(&#39;[ERROR] Incorrect amount of robot positions given&#39;)
                quit()
            # nun. of robots in robot file do not match swarm size in config file
            if len(robots) != config[2]:
                print(&#39;[ERROR] Mismatch between number of robots and swarm size given&#39;)
                quit()
            # num. of positions in positions file do not match swarm size in config gile
            if len(positions) != config[2]:
                print(&#39;[ERROR] Mismatch between number of positions and swarm size given&#39;)
                quit()

        env = Environment(int(config[0]), int(config[1]), int(config[2]))
        print(&#39;Rendering Robots...&#39;)
        for i, robot in enumerate(robots):                          # loop through robots in swarm
            env.renderRobot(robot)                                  # render robot
            # get any out of bounds robots
            if not self.cli and not build:
                out_of_bounds = robot.outOfBoundsDetect(int(config[0]), int(config[1]))
                if out_of_bounds != &#39;none&#39;:
                    self.out_of_bounds_all.append([i, out_of_bounds])
        print(&#39;...Done&#39;)
        if auto_pack:
            # auto-pack and reposition robots if option is selected
            print(&#39;Auto-packing Robots...&#39;)
            env.reposition(self.utils.autoPack(robots, config[0], config[1]))
            print(&#39;...Done&#39;)
        env.initialView()                                           # zoom camera out to look at all robots in scene
        if not auto_pack and not self.cli and not build:
            print(&#39;Detecting collisions...&#39;)
            # get any possible collisions between robots
            self.collisions = self.utils.collisionDetect(robots)
            print(&#39;...Done&#39;)
            # show error window if collisions or out of bounds are detected
            if len(self.collisions) &gt; 0 or len(self.out_of_bounds_all) &gt; 0:
                self.error_window()
        print(&#39;Rendering Environment...&#39;)
        env.run()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.RobotGUI.build_window"><code class="name flex">
<span>def <span class="ident">build_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the Robot building window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_window(self):
    &#34;&#34;&#34;Displays the Robot building window&#34;&#34;&#34;
    components = []
    connections = []
    treedata = sg.TreeData()

    # place core component in tree first
    core = Brick(&#39;Core&#39;, &#39;CoreComponent&#39;, True, 0)
    components.append(core)
    treedata.insert(parent=&#39;&#39;, key=core.id, text=core.id, values=[&#39;CoreComponent&#39;, core.orientation])
    # create UI layout
    layout = [[sg.Button(&#39;+&#39;, size=3, tooltip=&#39;add component&#39;), sg.Combo(values=COMPONENTS, default_value=COMPONENTS[0], key=&#39;-C_COMBO-&#39;, tooltip=&#39;component type&#39;),
               sg.InputText(key=&#39;-COMP_ID-&#39;, size=30, default_text=&#39;comp_id&#39;)],
              [sg.Text(&#39;Components&#39;)],
              [sg.Tree(data=treedata, key=&#34;-COMP_TREE-&#34;, auto_size_columns=True, num_rows=20, headings=[&#39;Type&#39;, &#39;Orientation&#39;], col0_width=30, expand_x=True, show_expanded=True), ],
              [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(&#39;Back&#39;, tooltip=&#39;return to file menu&#39;), sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)], target=&#39;-LOAD-&#39;, tooltip=&#39;load robot JSON&#39;),
              sg.Input(key=&#39;-LOAD-&#39;, enable_events=True, visible=False), sg.Checkbox(&#39;Write to file&#39;, default=True, key=&#39;-FILE-&#39;, tooltip=&#39;write robot to JSON&#39;),
              sg.InputText(key=&#39;-F_NAME-&#39;, size=30, default_text=&#39;robot_name&#39;)]]
    sg.theme(self.bgColour)
    window = sg.Window(&#34;Build a Robot&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
    while True:
        event, values = window.read()
        if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
            quit()
        if event == &#39;Back&#39;:
            # return to file menu
            break
        if event == &#39;Help&#39;:
            # show help window
            self.help_window(&#39;build&#39;)
        if event == &#39;-LOAD-&#39;:
            # user loads a JSON file from drive
            if values[&#39;-LOAD-&#39;] == &#39;&#39;:
                # if no file selected
                continue
            self.utils.robot_path = values[&#39;-LOAD-&#39;]
            # parse robot in from chosen file
            robot = self.utils.robotParse(1, [[0, 0, 0]], build=True)[0]
            for connection in robot.connections:
                dst = connection.dst
                # append components to the tree
                treedata.Insert(parent=connection.src.id, key=dst.id, text=dst.id, values=[dst.type, dst.orientation])
            window.Element(&#39;-COMP_TREE-&#39;).update(treedata)
            components = robot.components
            connections = robot.connections

        if event == &#39;+&#39;:
            # add new component
            if values[&#39;-COMP_ID-&#39;] in treedata.tree_dict:
                # if component id already exists in tree
                sg.popup(&#34;Component {} already exists&#34;.format(values[&#39;-COMP_ID-&#39;]))
                continue
            if &#39; &#39; in values[&#39;-COMP_ID-&#39;]:
                # if component name contains spaces
                sg.popup(&#34;No spaces in component ID&#34;)
                continue
            if len(values[&#39;-COMP_TREE-&#39;]) == 0:
                # if nothing selected, continue
                sg.popup(&#34;Please select a component&#34;)
                continue
            else:
                sel_comp = values[&#39;-COMP_TREE-&#39;][0]

            id = values[&#39;-COMP_ID-&#39;]
            type = values[&#39;-C_COMBO-&#39;]
            # open connection window to choose slots and orientation
            src_slot, dst_slot, orientation = self.connection_window()
            # find parent in component list
            parent = next(comp for comp in components if comp.id == sel_comp)

            if src_slot == -1 or dst_slot == -1 or orientation == -1:
                # if user exited window
                continue
            if &#39;Hinge&#39; in parent.type:
                # invalid src slot for hinge
                if src_slot in [2, 3]:
                    sg.popup(&#34;Invalid source slot for Hinge&#34;)
                    continue
            if &#39;Hinge&#39; in type:
                # invalid dst slot for hinge
                if dst_slot in [2, 3]:
                    sg.popup(&#34;Invalid destination slot for Hinge&#34;)
                    continue
                comp = Hinge(id, type, False, orientation)
            else:
                comp = Brick(id, type, False, orientation)

            treedata.Insert(parent=sel_comp, key=id, text=id, values=[type, orientation])   # insert new node
            window.Element(&#39;-COMP_TREE-&#39;).update(treedata)

            components.append(comp)
            connections.append(Connection(parent, comp, src_slot, dst_slot))

        if event == &#39;Submit&#39;:
            if len(components) == 1:
                # if only core comp. in tree
                sg.popup(&#34;Please add more than one component&#34;)
                continue
            if &#39; &#39; in values[&#39;-F_NAME-&#39;]:
                # if file name contains spaces
                sg.popup(&#34;No spaces in file name&#34;)
                continue
            robot = Robot(0, connections, components, [0, 0, 0])
            config = [1000, 1000, 1]                                # default config for 1 robot
            if (values[&#39;-FILE-&#39;]):
                self.utils.writeRobot(robot, values[&#39;-F_NAME-&#39;])    # write custom robot to JSON file
            window.hide()
            self.runSim(config=config, robots=[robot], build=True)  # run environment simulation with custom robot
            window.UnHide()

    window.close()</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotGUI.connection_window"><code class="name flex">
<span>def <span class="ident">connection_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the component connection window for specifying specific connection parameters</p>
<h2 id="returns">Returns</h2>
<p><code>(src_slot, dst_slot, orientation)</code>: source, dest slots + orientation of component ((int, int, int)) (returns (-1, -1, -1) if window closed)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connection_window(self):
    &#34;&#34;&#34;
    Displays the component connection window for specifying specific connection parameters
    Returns:
        `(src_slot, dst_slot, orientation)`: source, dest slots + orientation of component ((int, int, int)) (returns (-1, -1, -1) if window closed)
    &#34;&#34;&#34;
    layout = [[sg.Text(&#39;SRC Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-SRC_COMBO-&#39;)],
              [sg.Text(&#39;DST Slot:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-DST_COMBO-&#39;)],
              [sg.Text(&#39;Orientation:&#39;), sg.Combo(values=[0, 1, 2, 3], default_value=0, key=&#39;-O_COMBO-&#39;)],
              [sg.Button(&#39;Submit&#39;)]]
    sg.theme(self.bgColour)
    window = sg.Window(&#34;Enter Slots&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
    while True:
        event, values = window.read()
        if event == sg.WIN_CLOSED:
            window.close()
            return (-1, -1, -1)     # if user closes without entering anything, return (-1, -1, -1)
        if event == &#39;Submit&#39;:
            window.close()
            # return src_slot, dst_slot and orientation
            return (values[&#39;-SRC_COMBO-&#39;], values[&#39;-DST_COMBO-&#39;], values[&#39;-O_COMBO-&#39;])</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotGUI.error_window"><code class="name flex">
<span>def <span class="ident">error_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the error reporting window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_window(self):
    &#34;&#34;&#34;Displays the error reporting window&#34;&#34;&#34;
    if len(self.collisions) &gt; 0:
        # format robot collisions
        collision_text = formatCollisions(self.collisions)
        if len(self.out_of_bounds_all) &gt; 0:
            # format out of bounds errors
            out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
            # collisions and out of bounds
            layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                      [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                      [sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                      [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                      [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
        else:
            # only collisions
            layout = [[sg.Text(&#34;Robot Collisions&#34;, background_color=self.bgColour)],
                      [sg.Multiline(size=(50, 7), default_text=collision_text,  key=&#39;-COL_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                      [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]
    elif len(self.out_of_bounds_all) &gt; 0:
        out_of_bounds_text = formatOutOfBounds(self.out_of_bounds_all)
        # only out of bounds
        layout = [[sg.Text(&#34;Robots out of bounds&#34;, background_color=self.bgColour)],
                  [sg.Multiline(size=(50, 7), default_text=out_of_bounds_text,  key=&#39;-OOB_BOX-&#39;, echo_stdout_stderr=True, disabled=True)],
                  [sg.Button(&#39;Continue&#39;), sg.Button(&#39;Cancel&#39;)]]

    sg.theme(self.bgColour)
    window = sg.Window(&#34;Errors&#34;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
    while True:
        event, _ = window.read()
        if event == &#34;Continue&#34; or event == sg.WIN_CLOSED:
            # continue with program
            break
        if event == &#34;Cancel&#34;:
            # quit if user clicks cancel
            quit()

    window.close()</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotGUI.help_window"><code class="name flex">
<span>def <span class="ident">help_window</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the help window</p>
<h2 id="args">Args</h2>
<p><code>type</code>: type of help info to display (file or build), (String)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help_window(self, type):
    &#34;&#34;&#34;
    Displays the help window
    Args:
        `type`: type of help info to display (file or build), (String)
    &#34;&#34;&#34;
    # help in main GUI (loading from file)
    if type == &#39;file&#39;:
        help = &#34;To load a robot:\n  * browse for and choose a configuration, robot positions, and robot JSON file\n  * click on the &#39;Submit&#39; button to start the simulation\n(file formats are available in &#39;./docs/User_Manual.md&#39; under Appendix: File Formats)\n\nTo use auto-pack:\n  * toggle the &#39;auto-pack&#39; check box\n  * browse for and choose a configuration and robot JSON file\n  * click on the &#39;Submit&#39; button\n(positions will be automatically calculated and environment will be resized if needed)\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
    # help in build GUI (building a custom robot)
    elif type == &#39;build&#39;:
        help = &#34;To add a component:\n  * click the desired parent component in the tree\n  * select the desired type of component from the dropdown\n  * give the component an ID in the text box (&#39;comp_id&#39;)\n  * click the &#39;+&#39; button and fill in the source &amp; destination slots and orientation\n  * click on the &#39;Submit&#39; button to start the simulation\n\nTo load a robot from a JSON file click on the &#39;Browse&#39; button and select a robot JSON file\n\nBuilt robots can also be saved by checking &#39;Write to file&#39;, giving it a name and clicking &#39;Submit&#39;\n\nFull docs available under &#39;./docs/User_Manual.md&#39;&#34;
    layout = [[sg.Multiline(default_text=help, disabled=True, size=(70, 15), no_scrollbar=True)],
              [sg.Button(&#39;Ok&#39;)]]
    sg.theme(self.bgColour)
    window = sg.Window(&#39;Help&#39;, layout, modal=True, icon=&#39;resources/r_icon.ico&#39;)
    while True:
        event, _ = window.read()
        if event == sg.WIN_CLOSED or event == &#39;Ok&#39;:
            break
    window.close()</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotGUI.runSim"><code class="name flex">
<span>def <span class="ident">runSim</span></span>(<span>self, config='', robots='', auto_pack=False, build=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the Environment and runs the simulation</p>
<h2 id="args">Args</h2>
<p><code>auto_pack</code>: whether the packing algorithm will be used to auto-position the robots (Boolean) <strong>optional</strong><br>
<code>config</code>: configuration parameters (int[]) <strong>optional</strong>, only used when building a robot
<strong>optional</strong><br>
<code>robots</code>: array of Robots (Robot[]) <strong>optional</strong>, only used when building a robot
<strong>optional</strong><br>
<code>build</code>: whether or not simulation is being run from robot builder (boolean) <strong>optional</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runSim(self, config=&#39;&#39;, robots=&#39;&#39;, auto_pack=False, build=False):
    &#34;&#34;&#34;
    Creates the Environment and runs the simulation
    Args:
        `auto_pack`: whether the packing algorithm will be used to auto-position the robots (Boolean) **optional**  
        `config`: configuration parameters (int[]) **optional**, only used when building a robot  **optional**  
        `robots`: array of Robots (Robot[]) **optional**, only used when building a robot  **optional**  
        `build`: whether or not simulation is being run from robot builder (boolean) **optional**
    &#34;&#34;&#34;
    # CLI parsing and error checking
    if self.cli:
        # config parsing #
        config = self.utils.configParse()
        if not config:
            print(&#34;[ERROR] Incorrect configuration file format or file not found&#34;)
            quit()

        # positions parsing #
        positions = self.utils.posParse()
        if not positions:
            print(&#34;[ERROR] Incorrect positions file format or file not found&#34;)
            quit()

        # robot parsing #
        robots = self.utils.robotParse(int(config[2]), positions)
        if not robots:
            print(&#34;[ERROR] Incorrect robot file format or file not found&#34;)
            quit()
        elif robots == True:
            print(&#39;[ERROR] Incorrect amount of robot positions given&#39;)
            quit()
        # nun. of robots in robot file do not match swarm size in config file
        if len(robots) != config[2]:
            print(&#39;[ERROR] Mismatch between number of robots and swarm size given&#39;)
            quit()
        # num. of positions in positions file do not match swarm size in config gile
        if len(positions) != config[2]:
            print(&#39;[ERROR] Mismatch between number of positions and swarm size given&#39;)
            quit()

    env = Environment(int(config[0]), int(config[1]), int(config[2]))
    print(&#39;Rendering Robots...&#39;)
    for i, robot in enumerate(robots):                          # loop through robots in swarm
        env.renderRobot(robot)                                  # render robot
        # get any out of bounds robots
        if not self.cli and not build:
            out_of_bounds = robot.outOfBoundsDetect(int(config[0]), int(config[1]))
            if out_of_bounds != &#39;none&#39;:
                self.out_of_bounds_all.append([i, out_of_bounds])
    print(&#39;...Done&#39;)
    if auto_pack:
        # auto-pack and reposition robots if option is selected
        print(&#39;Auto-packing Robots...&#39;)
        env.reposition(self.utils.autoPack(robots, config[0], config[1]))
        print(&#39;...Done&#39;)
    env.initialView()                                           # zoom camera out to look at all robots in scene
    if not auto_pack and not self.cli and not build:
        print(&#39;Detecting collisions...&#39;)
        # get any possible collisions between robots
        self.collisions = self.utils.collisionDetect(robots)
        print(&#39;...Done&#39;)
        # show error window if collisions or out of bounds are detected
        if len(self.collisions) &gt; 0 or len(self.out_of_bounds_all) &gt; 0:
            self.error_window()
    print(&#39;Rendering Environment...&#39;)
    env.run()</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotGUI.startGUI"><code class="name flex">
<span>def <span class="ident">startGUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the file input GUI window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startGUI(self):
    &#34;&#34;&#34;Displays the file input GUI window&#34;&#34;&#34;

    LastRender = False
    # errors for file IO
    configError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
    posError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)
    jsonError = sg.Text(&#34;&#34;, visible=False, text_color=&#39;Red&#39;, background_color=self.bgColour)

    if(not exists(&#39;LastRender.txt&#39;)):
        # layout for if no previous file paths are found
        layout = [
            [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
            [sg.InputText(key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
            [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
            [sg.InputText(key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
            [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
            [sg.InputText(key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
            [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
        ]
    else:
        # if previous file paths found, read in and place in file path text boxes
        LastRender = True
        pos_path = &#34;&#34;
        config_path = &#34;&#34;
        robot_path = &#34;&#34;
        with open(&#39;LastRender.txt&#39;, &#39;r&#39;) as f:
            i = 0
            for line in f:
                line = line.strip()
                if i == 0:
                    pos_path = line
                elif i == 1:
                    config_path = line
                elif i == 2:
                    robot_path = line
                i += 1
        layout = [
            [sg.Text(&#34;Choose a config file:&#34;, background_color=self.bgColour)],
            [sg.InputText(default_text=config_path, key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Configuration file&#34;, &#34;*.txt&#34;)])], [configError],
            [sg.Text(&#34;Choose a positions file:&#34;, background_color=self.bgColour)],
            [sg.InputText(default_text=pos_path, key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Position file&#34;, &#34;*.txt&#34;)])], [posError],
            [sg.Text(&#34;Choose a robots file:&#34;, background_color=self.bgColour)],
            [sg.InputText(default_text=robot_path, key=&#34;-FILE_PATH-&#34;),
             sg.FileBrowse(initial_folder=self.working_directory, file_types=[(&#34;Robot file&#34;, &#34;*.json&#34;)])], [jsonError],
            [sg.Button(&#39;Submit&#39;, tooltip=&#39;start simulation&#39;), sg.Button(&#39;Help&#39;, tooltip=&#39;help menu&#39;), sg.Button(
                &#39;Build&#39;, tooltip=&#39;open robot building menu&#39;), sg.Exit(), sg.Checkbox(&#39;Auto-pack&#39;, key=&#39;-A_PACK-&#39;, tooltip=&#39;auto-position robots&#39;)]
        ]

    sg.theme(self.bgColour)
    window = sg.Window(&#34;RoboViz&#34;, layout, icon=&#39;resources/r_icon.ico&#39;)

    # Main Program Loop
    while True:
        auto_pack = False
        event, values = window.read()

        if event == sg.WIN_CLOSED or event == &#39;Exit&#39;:
            break

        elif (event == &#34;Help&#34;):
            # show help window
            self.help_window(&#39;file&#39;)

        elif (event == &#34;Build&#34;):
            # switch to build window and hide file window
            window.hide()
            self.build_window()
            window.UnHide()

        # show file IO errors if a file is left out
        elif (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] == &#34;&#34;):
            configError.update(value=&#34;Configuration file not included&#34;, visible=True)
        else:
            configError.update(visible=False)

        if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-0&#34;] == &#34;&#34; and not values[&#39;-A_PACK-&#39;]):
            posError.update(value=&#34;Positions file not included&#34;, visible=True)
        else:
            posError.update(visible=False)

        if (event == &#34;Submit&#34; and values[&#34;-FILE_PATH-2&#34;] == &#34;&#34;):
            jsonError.update(value=&#34;Robots file not included&#34;, visible=True)
        else:
            jsonError.update(visible=False)

        # if all file paths given OR if config and robot paths given and auto-pack enabled (positions not required)
        if ((event == &#34;Submit&#34; and values[&#34;-FILE_PATH-&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-0&#34;] != &#34;&#34; and values[&#34;-FILE_PATH-2&#34;] != &#34;&#34;) or (event == &#39;Submit&#39; and values[&#39;-A_PACK-&#39;])):
            if values[&#39;-A_PACK-&#39;]:
                auto_pack = True
            self.config_path = values[&#34;-FILE_PATH-&#34;]
            self.pos_path = values[&#34;-FILE_PATH-0&#34;]
            self.robot_path = values[&#34;-FILE_PATH-2&#34;]

            # GUI parsing and error checking
            self.utils = RobotUtils(self.config_path, self.pos_path, self.robot_path)
            # config parsing #
            config = self.utils.configParse()
            if not config:
                configError.update(value=&#34;Incorrect configuration file format&#34;, visible=True)
                continue
            else:
                configError.update(visible=False)
            if not auto_pack:
                # positions parsing #
                positions = self.utils.posParse()
                if not positions:
                    posError.update(value=&#34;Incorrect positions file format&#34;, visible=True)
                    continue
                else:
                    posError.update(visible=False)
            else:
                # default positions for auto-pack to use
                positions = [[0, 0, 0]]*int(config[2])
            # robots parsing #
            robots = self.utils.robotParse(int(config[2]), positions)
            if not robots:
                jsonError.update(value=&#34;Incorrect robot file format&#34;, visible=True)
                continue
            elif robots == True:
                posError.update(value=&#34;Incorrect amount of robot positions given&#34;, visible=True)
                continue
            else:
                jsonError.update(visible=False)
            # num. of robots in robot file do not match swarm size in config file
            if len(robots) != config[2]:
                configError.update(value=&#34;Mismatch between swarm size and number of robots given&#34;, visible=True)
                continue
            # num. of positions in positions file do not match swarm size in config file
            if len(positions) != config[2]:
                posError.update(value=&#34;Mismatch between number of positions and swarm size given&#34;, visible=True)
                continue

            # write chosen file paths to file
            lines = [self.pos_path, self.config_path, self.robot_path]
            with open(&#39;LastRender.txt&#39;, &#39;w&#39;) as f:
                for line in lines:
                    f.write(line)
                    f.write(&#39; \n&#39;)

            window.hide()                                       # hide GUI window
            self.runSim(config, robots, auto_pack=auto_pack)    # start simulation (Panda)
            window.UnHide()                                     # show GUI window again after exiting Panda

    window.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.RobotUtils"><code class="flex name class">
<span>class <span class="ident">RobotUtils</span></span>
<span>(</span><span>config_path, pos_path, robot_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains various utility functions (such as file IO) for creating robots</p>
<p>Constructor</p>
<h2 id="args">Args</h2>
<p><code>config_path</code>: file path of configuration text file (String)<br>
<code>pos_path</code>: file path of robot positions text file (String)<br>
<code>robot_path</code>: file path of robot JSON file (String)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RobotUtils:
    &#34;&#34;&#34;Contains various utility functions (such as file IO) for creating robots&#34;&#34;&#34;

    def __init__(self, config_path, pos_path, robot_path):
        &#34;&#34;&#34;
        Constructor
        Args:
            `config_path`: file path of configuration text file (String)  
            `pos_path`: file path of robot positions text file (String)  
            `robot_path`: file path of robot JSON file (String)
        &#34;&#34;&#34;
        self.config_path = config_path
        self.pos_path = pos_path
        self.robot_path = robot_path

    def collisionDetect(self, robots):
        &#34;&#34;&#34;
        Determines if there are any possible collisions between robots in the scene
            Args:
                `robots`: list of all robots in the scene (Robot[])
            Returns
                `collisions`: possible collisions between robots (int[][])
        &#34;&#34;&#34;
        collisions = []
        for i, first_robot in enumerate(robots):
            for second_robot in robots[i + 1:]:
                # if robots cross each other&#39;s z bounds
                if first_robot.bounds[4] &gt;= second_robot.bounds[5] and first_robot.bounds[5] &lt;= second_robot.bounds[4]:
                    # if robots cross each other&#39;s x bounds
                    if first_robot.bounds[0] &gt;= second_robot.bounds[1] and first_robot.bounds[1] &lt;= second_robot.bounds[0]:
                        # if robots cross each other&#39;s y bounds
                        if first_robot.bounds[2] &gt;= second_robot.bounds[3] and first_robot.bounds[3] &lt;= second_robot.bounds[2]:
                            collisions.append([first_robot.id, second_robot.id])
        return collisions

    def createBrain(self, components, brain, neurons):
        &#34;&#34;&#34;
        Creates list of neurons based on JSON file ANN inputs
        Args:
            `components`: components in Robot (RobotComp[])  
            `brain`: connections in Robot brain (dict)  
            `neurons`: neurons in Robot brain (dict)
        &#34;&#34;&#34;
        inputNeurons = 0
        outputNeurons = 0
        outputPortIds = []
        params = []
        types = []
        for i in neurons:
            type = i[&#39;type&#39;]
            # read in json file
            gain = i[&#39;gain&#39;]
            params.append(gain)
            if type == &#39;sigmoid&#39;:
                bias = i[&#39;bias&#39;]
                params.append(bias)
                types.append(1)
                outputNeurons = outputNeurons + 1
                outputPortIds.append(i[&#39;bodyPartId&#39;])
            elif type == &#39;oscillator&#39;:
                phaseOffset = i[&#39;phaseOffset&#39;]
                period = i[&#39;period&#39;]
                params.append(period)
                params.append(phaseOffset)
                types.append(3)
                outputNeurons = outputNeurons + 1
                outputPortIds.append(i[&#39;bodyPartId&#39;])
            else:
                inputNeurons = inputNeurons+1
        weightArr = []
        destComps = []
        # set up the weights &amp; destination comps
        count = 0
        for j in components:
            for k in outputPortIds:
                if j.id in k:
                    destComps.append(j)
        for i in brain:
            weight = i[&#39;weight&#39;]
            weightArr.append(weight)
        return ann(destComps, inputNeurons, outputNeurons, weightArr, params, types)

    def writeRobot(self, robot, name):
        &#34;&#34;&#34;
        Writes custom built Robot out to relevant files
        Args:
            `robot`: Robot to be written out (Robot)  
            `name`: name of Robot JSON file (String)
        &#34;&#34;&#34;
        path = &#39;json/{}.json&#39;.format(name)
        dict_outer = {}
        dict_inner = {}
        connections = list(robot.connections)
        components = list(robot.components)

        with open(path, &#39;w&#39;) as f:
            # get all components &amp; connections as dicts
            for i, component in enumerate(components):
                components[i] = component.as_dict()
            for i, connection in enumerate(connections):
                connections[i] = connection.as_dict()

            # construct JSON file sections
            dict_inner[&#34;part&#34;] = components
            dict_inner[&#34;connection&#34;] = connections
            dict_outer[&#34;id&#34;] = robot.id
            dict_outer[&#34;body&#34;] = dict_inner

            # write to JSON file
            json.dump(dict_outer, f, indent=4)

    def posParse(self):
        &#34;&#34;&#34;
        Parses robot positions from positions file
        Returns:
            `positions`: positions of Robots in scene (int[])
        &#34;&#34;&#34;
        try:
            positions = []
            with open(self.pos_path, &#39;r&#39;) as f:
                for line in f:
                    robot_position = []
                    line = line.split(&#39; &#39;)
                    robot_position.append(int(line[0]))  # x value
                    robot_position.append(int(line[1]))  # y value
                    robot_position.append(int(line[2]))  # z value
                    positions.append(robot_position)
            return positions
        except:
            # format error or file not found
            return False

    def configParse(self):
        &#34;&#34;&#34;
        Parses environment and swarm size from configuration file
        Returns:
            `configuration`: environment and swarm size (int[])
        &#34;&#34;&#34;
        try:
            configuration = []
            with open(self.config_path, &#39;r&#39;) as f:
                for line in f:
                    configuration.append(int(line))
            return configuration
        except:
            # format error or file not found
            return False

    def robotParse(self, swarm_size, positions, build=False):
        &#34;&#34;&#34;
        Parses robot(s) from robot JSON file
        Args:
            `swarm_size`: number of robots in swarm (int)  
            `positions`: positions of each robot in swarm (int[])  
            `build`: whether or not robot is being loaded into builder (boolean) **optional**
        Returns:
            `robotArr`: all robots to be rendered in the scene (Robot[])
        &#34;&#34;&#34;
        try:
            robotArr = []
            count = 0  # counting the positions
            with open(self.robot_path, &#39;r&#39;) as f:
                data = json.load(f)
            # HETERGENEOUS SWARM
            if(&#34;swarm&#34; in data.keys()):
                swarm = data[&#34;swarm&#34;]

                for robot in swarm:
                    roboId = robot[&#34;id&#34;]
                    body = robot[&#34;body&#34;]

                    bodyComp = body[&#34;part&#34;]
                    compArr = []

                    for i in bodyComp:
                        id = i[&#39;id&#39;]
                        type = i[&#39;type&#39;]
                        root = i[&#39;root&#39;]
                        orient = i[&#39;orientation&#39;]
                        # determine component type
                        if &#39;Hinge&#39; in type:
                            newComp = Hinge(id, type, root, orient)     # create new Hinge component
                        else:
                            newComp = Brick(id, type, root, orient)     # create new Brick component

                        compArr.append(newComp)

                    bodyConnect = body[&#34;connection&#34;]
                    connArr = []

                    for i in bodyConnect:
                        src = i[&#39;src&#39;]
                        # find the component that is the source
                        for j in compArr:
                            compare = j.id
                            if src == compare:
                                src = j

                        dest = i[&#39;dest&#39;]
                        # find the component that is the destination
                        for j in compArr:
                            if dest == (j.id):
                                dest = j

                        srcSlot = i[&#39;srcSlot&#39;]
                        # find the component that is the source slot
                        for j in compArr:
                            if srcSlot == (j.id):
                                srcSlot = j

                        destSlot = i[&#39;destSlot&#39;]
                        # find the component that is the destination slot
                        for j in compArr:
                            if destSlot == (j.id):
                                srcSlot = j

                        newCon = Connection(src, dest, srcSlot, destSlot)               # construct new connection
                        connArr.append(newCon)                                          # add to list of connections

                    robot = Robot(roboId, connArr, compArr, positions[count - 1])
                    count += 1
                    robotArr.append(robot)
                return robotArr
            # HOMOGENOUS SWARM
            else:
                roboId = data[&#34;id&#34;]
                body = data[&#34;body&#34;]
                bodyComp = body[&#34;part&#34;]
                compArr = []

                for i in bodyComp:
                    id = i[&#39;id&#39;]
                    type = i[&#39;type&#39;]
                    root = i[&#39;root&#39;]
                    orient = i[&#39;orientation&#39;]
                    if &#39;Hinge&#39; in type:
                        newComp = Hinge(id, type, root, orient)                     # create new Hinge component
                    else:
                        newComp = Brick(id, type, root, orient)                     # create new Brick component
                    compArr.append(newComp)

                bodyConnect = body[&#34;connection&#34;]
                connArr = []

                for i in bodyConnect:
                    src = i[&#39;src&#39;]
                    # find the component that is the source
                    for j in compArr:
                        compare = j.id
                        if src == compare:
                            src = j

                    dest = i[&#39;dest&#39;]
                    # find the component that is the destination
                    for j in compArr:
                        if dest == (j.id):
                            dest = j

                    srcSlot = i[&#39;srcSlot&#39;]
                    # find the component that is the source slot
                    for j in compArr:
                        if srcSlot == (j.id):
                            srcSlot = j

                    destSlot = i[&#39;destSlot&#39;]
                    # find the component that is the destination slot
                    for j in compArr:
                        if destSlot == (j.id):
                            srcSlot = j

                    newCon = Connection(src, dest, srcSlot, destSlot)
                    connArr.append(newCon)
                if CREATE_BRAIN:
                    network = data[&#34;brain&#34;]
                    neurons = network[&#34;neuron&#34;]
                    brain = network[&#34;connection&#34;]
                    ann = self.createBrain(compArr, brain, neurons)
                for i in range(int(swarm_size)):                      # loop through robots in swarm
                    if not build:
                        connArr = deepcopy(connArr)
                    robotArr.append(Robot(i, connArr, compArr, positions[i]))
                return robotArr
        except IndexError:
            # means incorrect number of positions given
            return True
        except:
            # format error or file not found
            return False

    def autoPack(self, robots, x_length, y_length):
        &#34;&#34;&#34;
        Calculates automatic positioning of Robots to fit within certain bounds (resizes environment if not possible)
        Args:
            `robots`: Robots in the Environment (Robot[])  
            `x_length`: current x-dim of the environment  
            `y_length`: current y-dim of the environment
        Returns:
            `(positions, x_length, y_length)`: new positions of Robots + new dims of environment
        &#34;&#34;&#34;
        while True:
            try:
                sizes = []
                # get bounding box sizes for all robots
                for robot in robots:
                    bounds = robot.bounds
                    width = int(bounds[0]) - int(bounds[1]) + PACK_BUFFER
                    height = int(bounds[2]) - int(bounds[3]) + PACK_BUFFER
                    sizes.append((width, height))

                # calculate optimal packing positions
                positions = rpack.pack(sizes, max_width=y_length, max_height=x_length)
                box_size = rpack.bbox_size(sizes, positions)    # size of packed robots

                # adjust positions so that they&#39;re at the centre of each robot bounding box
                # (originally put at bottom left corner)
                for i, _ in enumerate(positions):
                    bounds = robots[i].bounds
                    core_pos = robot.core_pos
                    positions[i] = (positions[i][0] + core_pos[0] - bounds[1] - box_size[0]/2,
                                    positions[i][1] + core_pos[1] - bounds[3] - box_size[1]/2)
            except rpack.PackingImpossibleError:
                # can&#39;t pack into environment dims
                # resize environment and try again
                x_length += INC_AMT
                y_length += INC_AMT
                continue
            else:
                break
        return (positions, x_length, y_length)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.RobotUtils.autoPack"><code class="name flex">
<span>def <span class="ident">autoPack</span></span>(<span>self, robots, x_length, y_length)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates automatic positioning of Robots to fit within certain bounds (resizes environment if not possible)</p>
<h2 id="args">Args</h2>
<p><code>robots</code>: Robots in the Environment (Robot[])<br>
<code>x_length</code>: current x-dim of the environment<br>
<code>y_length</code>: current y-dim of the environment</p>
<h2 id="returns">Returns</h2>
<p><code>(positions, x_length, y_length)</code>: new positions of Robots + new dims of environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoPack(self, robots, x_length, y_length):
    &#34;&#34;&#34;
    Calculates automatic positioning of Robots to fit within certain bounds (resizes environment if not possible)
    Args:
        `robots`: Robots in the Environment (Robot[])  
        `x_length`: current x-dim of the environment  
        `y_length`: current y-dim of the environment
    Returns:
        `(positions, x_length, y_length)`: new positions of Robots + new dims of environment
    &#34;&#34;&#34;
    while True:
        try:
            sizes = []
            # get bounding box sizes for all robots
            for robot in robots:
                bounds = robot.bounds
                width = int(bounds[0]) - int(bounds[1]) + PACK_BUFFER
                height = int(bounds[2]) - int(bounds[3]) + PACK_BUFFER
                sizes.append((width, height))

            # calculate optimal packing positions
            positions = rpack.pack(sizes, max_width=y_length, max_height=x_length)
            box_size = rpack.bbox_size(sizes, positions)    # size of packed robots

            # adjust positions so that they&#39;re at the centre of each robot bounding box
            # (originally put at bottom left corner)
            for i, _ in enumerate(positions):
                bounds = robots[i].bounds
                core_pos = robot.core_pos
                positions[i] = (positions[i][0] + core_pos[0] - bounds[1] - box_size[0]/2,
                                positions[i][1] + core_pos[1] - bounds[3] - box_size[1]/2)
        except rpack.PackingImpossibleError:
            # can&#39;t pack into environment dims
            # resize environment and try again
            x_length += INC_AMT
            y_length += INC_AMT
            continue
        else:
            break
    return (positions, x_length, y_length)</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.collisionDetect"><code class="name flex">
<span>def <span class="ident">collisionDetect</span></span>(<span>self, robots)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if there are any possible collisions between robots in the scene
Args:
<code>robots</code>: list of all robots in the scene (Robot[])
Returns
<code>collisions</code>: possible collisions between robots (int[][])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collisionDetect(self, robots):
    &#34;&#34;&#34;
    Determines if there are any possible collisions between robots in the scene
        Args:
            `robots`: list of all robots in the scene (Robot[])
        Returns
            `collisions`: possible collisions between robots (int[][])
    &#34;&#34;&#34;
    collisions = []
    for i, first_robot in enumerate(robots):
        for second_robot in robots[i + 1:]:
            # if robots cross each other&#39;s z bounds
            if first_robot.bounds[4] &gt;= second_robot.bounds[5] and first_robot.bounds[5] &lt;= second_robot.bounds[4]:
                # if robots cross each other&#39;s x bounds
                if first_robot.bounds[0] &gt;= second_robot.bounds[1] and first_robot.bounds[1] &lt;= second_robot.bounds[0]:
                    # if robots cross each other&#39;s y bounds
                    if first_robot.bounds[2] &gt;= second_robot.bounds[3] and first_robot.bounds[3] &lt;= second_robot.bounds[2]:
                        collisions.append([first_robot.id, second_robot.id])
    return collisions</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.configParse"><code class="name flex">
<span>def <span class="ident">configParse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses environment and swarm size from configuration file</p>
<h2 id="returns">Returns</h2>
<p><code>configuration</code>: environment and swarm size (int[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configParse(self):
    &#34;&#34;&#34;
    Parses environment and swarm size from configuration file
    Returns:
        `configuration`: environment and swarm size (int[])
    &#34;&#34;&#34;
    try:
        configuration = []
        with open(self.config_path, &#39;r&#39;) as f:
            for line in f:
                configuration.append(int(line))
        return configuration
    except:
        # format error or file not found
        return False</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.createBrain"><code class="name flex">
<span>def <span class="ident">createBrain</span></span>(<span>self, components, brain, neurons)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates list of neurons based on JSON file ANN inputs</p>
<h2 id="args">Args</h2>
<p><code>components</code>: components in Robot (RobotComp[])<br>
<code>brain</code>: connections in Robot brain (dict)<br>
<code>neurons</code>: neurons in Robot brain (dict)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createBrain(self, components, brain, neurons):
    &#34;&#34;&#34;
    Creates list of neurons based on JSON file ANN inputs
    Args:
        `components`: components in Robot (RobotComp[])  
        `brain`: connections in Robot brain (dict)  
        `neurons`: neurons in Robot brain (dict)
    &#34;&#34;&#34;
    inputNeurons = 0
    outputNeurons = 0
    outputPortIds = []
    params = []
    types = []
    for i in neurons:
        type = i[&#39;type&#39;]
        # read in json file
        gain = i[&#39;gain&#39;]
        params.append(gain)
        if type == &#39;sigmoid&#39;:
            bias = i[&#39;bias&#39;]
            params.append(bias)
            types.append(1)
            outputNeurons = outputNeurons + 1
            outputPortIds.append(i[&#39;bodyPartId&#39;])
        elif type == &#39;oscillator&#39;:
            phaseOffset = i[&#39;phaseOffset&#39;]
            period = i[&#39;period&#39;]
            params.append(period)
            params.append(phaseOffset)
            types.append(3)
            outputNeurons = outputNeurons + 1
            outputPortIds.append(i[&#39;bodyPartId&#39;])
        else:
            inputNeurons = inputNeurons+1
    weightArr = []
    destComps = []
    # set up the weights &amp; destination comps
    count = 0
    for j in components:
        for k in outputPortIds:
            if j.id in k:
                destComps.append(j)
    for i in brain:
        weight = i[&#39;weight&#39;]
        weightArr.append(weight)
    return ann(destComps, inputNeurons, outputNeurons, weightArr, params, types)</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.posParse"><code class="name flex">
<span>def <span class="ident">posParse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses robot positions from positions file</p>
<h2 id="returns">Returns</h2>
<p><code>positions</code>: positions of Robots in scene (int[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def posParse(self):
    &#34;&#34;&#34;
    Parses robot positions from positions file
    Returns:
        `positions`: positions of Robots in scene (int[])
    &#34;&#34;&#34;
    try:
        positions = []
        with open(self.pos_path, &#39;r&#39;) as f:
            for line in f:
                robot_position = []
                line = line.split(&#39; &#39;)
                robot_position.append(int(line[0]))  # x value
                robot_position.append(int(line[1]))  # y value
                robot_position.append(int(line[2]))  # z value
                positions.append(robot_position)
        return positions
    except:
        # format error or file not found
        return False</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.robotParse"><code class="name flex">
<span>def <span class="ident">robotParse</span></span>(<span>self, swarm_size, positions, build=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses robot(s) from robot JSON file</p>
<h2 id="args">Args</h2>
<p><code>swarm_size</code>: number of robots in swarm (int)<br>
<code>positions</code>: positions of each robot in swarm (int[])<br>
<code>build</code>: whether or not robot is being loaded into builder (boolean) <strong>optional</strong></p>
<h2 id="returns">Returns</h2>
<p><code>robotArr</code>: all robots to be rendered in the scene (Robot[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def robotParse(self, swarm_size, positions, build=False):
    &#34;&#34;&#34;
    Parses robot(s) from robot JSON file
    Args:
        `swarm_size`: number of robots in swarm (int)  
        `positions`: positions of each robot in swarm (int[])  
        `build`: whether or not robot is being loaded into builder (boolean) **optional**
    Returns:
        `robotArr`: all robots to be rendered in the scene (Robot[])
    &#34;&#34;&#34;
    try:
        robotArr = []
        count = 0  # counting the positions
        with open(self.robot_path, &#39;r&#39;) as f:
            data = json.load(f)
        # HETERGENEOUS SWARM
        if(&#34;swarm&#34; in data.keys()):
            swarm = data[&#34;swarm&#34;]

            for robot in swarm:
                roboId = robot[&#34;id&#34;]
                body = robot[&#34;body&#34;]

                bodyComp = body[&#34;part&#34;]
                compArr = []

                for i in bodyComp:
                    id = i[&#39;id&#39;]
                    type = i[&#39;type&#39;]
                    root = i[&#39;root&#39;]
                    orient = i[&#39;orientation&#39;]
                    # determine component type
                    if &#39;Hinge&#39; in type:
                        newComp = Hinge(id, type, root, orient)     # create new Hinge component
                    else:
                        newComp = Brick(id, type, root, orient)     # create new Brick component

                    compArr.append(newComp)

                bodyConnect = body[&#34;connection&#34;]
                connArr = []

                for i in bodyConnect:
                    src = i[&#39;src&#39;]
                    # find the component that is the source
                    for j in compArr:
                        compare = j.id
                        if src == compare:
                            src = j

                    dest = i[&#39;dest&#39;]
                    # find the component that is the destination
                    for j in compArr:
                        if dest == (j.id):
                            dest = j

                    srcSlot = i[&#39;srcSlot&#39;]
                    # find the component that is the source slot
                    for j in compArr:
                        if srcSlot == (j.id):
                            srcSlot = j

                    destSlot = i[&#39;destSlot&#39;]
                    # find the component that is the destination slot
                    for j in compArr:
                        if destSlot == (j.id):
                            srcSlot = j

                    newCon = Connection(src, dest, srcSlot, destSlot)               # construct new connection
                    connArr.append(newCon)                                          # add to list of connections

                robot = Robot(roboId, connArr, compArr, positions[count - 1])
                count += 1
                robotArr.append(robot)
            return robotArr
        # HOMOGENOUS SWARM
        else:
            roboId = data[&#34;id&#34;]
            body = data[&#34;body&#34;]
            bodyComp = body[&#34;part&#34;]
            compArr = []

            for i in bodyComp:
                id = i[&#39;id&#39;]
                type = i[&#39;type&#39;]
                root = i[&#39;root&#39;]
                orient = i[&#39;orientation&#39;]
                if &#39;Hinge&#39; in type:
                    newComp = Hinge(id, type, root, orient)                     # create new Hinge component
                else:
                    newComp = Brick(id, type, root, orient)                     # create new Brick component
                compArr.append(newComp)

            bodyConnect = body[&#34;connection&#34;]
            connArr = []

            for i in bodyConnect:
                src = i[&#39;src&#39;]
                # find the component that is the source
                for j in compArr:
                    compare = j.id
                    if src == compare:
                        src = j

                dest = i[&#39;dest&#39;]
                # find the component that is the destination
                for j in compArr:
                    if dest == (j.id):
                        dest = j

                srcSlot = i[&#39;srcSlot&#39;]
                # find the component that is the source slot
                for j in compArr:
                    if srcSlot == (j.id):
                        srcSlot = j

                destSlot = i[&#39;destSlot&#39;]
                # find the component that is the destination slot
                for j in compArr:
                    if destSlot == (j.id):
                        srcSlot = j

                newCon = Connection(src, dest, srcSlot, destSlot)
                connArr.append(newCon)
            if CREATE_BRAIN:
                network = data[&#34;brain&#34;]
                neurons = network[&#34;neuron&#34;]
                brain = network[&#34;connection&#34;]
                ann = self.createBrain(compArr, brain, neurons)
            for i in range(int(swarm_size)):                      # loop through robots in swarm
                if not build:
                    connArr = deepcopy(connArr)
                robotArr.append(Robot(i, connArr, compArr, positions[i]))
            return robotArr
    except IndexError:
        # means incorrect number of positions given
        return True
    except:
        # format error or file not found
        return False</code></pre>
</details>
</dd>
<dt id="RoboViz.RobotUtils.writeRobot"><code class="name flex">
<span>def <span class="ident">writeRobot</span></span>(<span>self, robot, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes custom built Robot out to relevant files</p>
<h2 id="args">Args</h2>
<p><code>robot</code>: Robot to be written out (Robot)<br>
<code>name</code>: name of Robot JSON file (String)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeRobot(self, robot, name):
    &#34;&#34;&#34;
    Writes custom built Robot out to relevant files
    Args:
        `robot`: Robot to be written out (Robot)  
        `name`: name of Robot JSON file (String)
    &#34;&#34;&#34;
    path = &#39;json/{}.json&#39;.format(name)
    dict_outer = {}
    dict_inner = {}
    connections = list(robot.connections)
    components = list(robot.components)

    with open(path, &#39;w&#39;) as f:
        # get all components &amp; connections as dicts
        for i, component in enumerate(components):
            components[i] = component.as_dict()
        for i, connection in enumerate(connections):
            connections[i] = connection.as_dict()

        # construct JSON file sections
        dict_inner[&#34;part&#34;] = components
        dict_inner[&#34;connection&#34;] = connections
        dict_outer[&#34;id&#34;] = robot.id
        dict_outer[&#34;body&#34;] = dict_inner

        # write to JSON file
        json.dump(dict_outer, f, indent=4)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="RoboViz.ann"><code class="flex name class">
<span>class <span class="ident">ann</span></span>
<span>(</span><span>components, inputs, outputs, weights, params, type)</span>
</code></dt>
<dd>
<div class="desc"><p>This class handles all functionality for the brain of the robot.</p>
<p>Constructor for the neural network.</p>
<p>Initializes parameters.</p>
<h2 id="args">Args</h2>
<p><code>components</code>: the components that make up the output ports (RobotComp[])<br>
<code>inputs</code>: the number of input neurons (int)<br>
<code>outputs</code>: the number of output neurons (int)<br>
<code>weights</code>: array of weights that go from the beginning to the end of the network (double[])<br>
<code>params</code>: bias, gain, period and offset for output neurons (double[])<br>
<code>type</code>: sigmoid/oscillator/input neuron (String[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ann:
    &#34;&#34;&#34;This class handles all functionality for the brain of the robot.&#34;&#34;&#34;

    def __init__(self, components, inputs, outputs, weights, params, type):
        &#34;&#34;&#34;
        Constructor for the neural network.

        Initializes parameters.

        Args:
            `components`: the components that make up the output ports (RobotComp[])  
            `inputs`: the number of input neurons (int)  
            `outputs`: the number of output neurons (int)  
            `weights`: array of weights that go from the beginning to the end of the network (double[])  
            `params`: bias, gain, period and offset for output neurons (double[])  
            `type`: sigmoid/oscillator/input neuron (String[])

        &#34;&#34;&#34;
        # max is either (bias, tau, gain) or (phase offset, period, gain)
        self.MAX_PARAMS = 3

        # Branch Hip1 0 to D9
        D9 = 0
        # Branch Hip2 0 to D10
        D10 = 0
        # Branch Hip3 0 to D5
        D5 = 0
        # Branch Knee2 0 to D6
        D6 = 0
        # Branch myid1001 0 to D11
        D11 = 0
        # Branch myid1003 0 to D13
        D13 = 0
        # Branch myid1007 0 to ROLL
        ROLL = 0
        # Branch myid1018 0 to PITCH
        PITCH = 0
        self.outputPorts = []

        for i in components:
            self.outputPorts.append(i)

        NB_LIGHTSENSORS = 0
        NB_TOUCH_SENSORS = 0
        NB_IR_SENSORS = 0
        NB_SERVO_MOTORS = outputs
        NB_ROTATION_MOTORS = 0
        NB_ACC_GYRO_SENSORS = inputs

        # input ports: 0 for lightSensor,
        # type of input: 2 for Accelerometer and Gyroscope
        inputTab = []
        x = [0, 2]
        for i in range(inputs):
            inputTab.append(x)

        # FALSE if not irSensor, otherwise index of irSensor
        irIndices = [False, False, False, False, False, False]

        # first arg = value of the output port
        # second arg = type of the output:
        # 0 for position control, and 1 for velocity control

        outputTab = []
        for o in range(outputs):
            outputTab.append([self.outputPorts[o], 0])

        self.inputs = inputs
        self.outputs = outputs
        self.weights = weights
        self.params = params

        # for sigmoid: bias, tau(input or time?), gain
        # for oscilator: period, phase offset (from a central clock), gain
        # oscillator neurons do not receive any input, but rather output a sinusoid oscillation as a function of time
        self.Types = type
        # 1 = sigmoid, 3 = oscillator
        self.initNetwork()

    def initNetwork(self):
        &#34;&#34;&#34;
        Initializes the input and output states in the neural network to 0.

        The state is the output of each neuron in the network.
        &#34;&#34;&#34;
        self.state = []
        # Initialize states
        for o in range(self.outputs):
            self.state.append(0.0)

        # Initialize inputs
        for i in range(self.inputs):
            self.state.append(0.0)

    def feed(self, input):
        &#34;&#34;&#34;
        Feeds the network with an array of inputs from the sensors. Only initializes the network&#39;s current input variable.

        Args:
            `input`: the number of input neurons (int[])
        &#34;&#34;&#34;
        self.input = []
        print(&#34;Creating brain . . .&#34;)
        print(&#34;Input from sensors: &#34;, input)
        for i in range(self.inputs):
            self.input.append(input[i])

    def step(self, time):
        &#34;&#34;&#34;
        Feeds the input data into the neural network. For each input from a sensor, the data is fed into the corresponding neuron and transformed via its activation function.
        This data is propogated through the network to the output layer. The state of each neuron is changed accordingly.

        Args:
            `time`: from the python.time() library, used to set the state for the oscillator neurons (float)
        &#34;&#34;&#34;
        PI = math.pi
        baseIndexOutputWeights = (self.outputs)*(self.inputs)
        # For each hidden and output neuron, sum the state of all incoming connections
        self.activations = []
        for o in range(self.outputs):
            self.activations.append(o)
            for i in range(self.inputs):
                self.activations[o] = self.activations[o]+self.weights[(self.outputs-1)*i+o]*self.state[i]
            for i in range(self.outputs):
                self.activations[o] = self.activations[o]+self.weights[baseIndexOutputWeights]+(self.outputs-1)*i+o*self.state[i]
        # Add in biases and calculate new network state/do appropriate operation for neuron type

        for o in range(self.outputs):
            # save the next state
            if self.Types[o] == 1:
                # params are bias and gain
                self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
                self.state[o] = (1.0/(1.0 + math.exp(-1*(self.params[self.MAX_PARAMS*o+1]))))*self.activations[o]
            elif self.Types[o] == 0:
                # linear, params are bias and gain
                self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
                self.state[o] = self.params[self.MAX_PARAMS*o+1]*self.activations[o]
            elif(self.Types[o] == 3):
                # params are period, phase offset, gain (amplitude)
                period = self.params[self.MAX_PARAMS * o]
                phaseOffset = self.params[self.MAX_PARAMS * o + 1]
                gain = self.params[self.MAX_PARAMS * o + 2]
                self.state[o] = ((math.sin((2.0 * PI / period)*(time - period * phaseOffset))) + 1.0) / 2.0
                self.state[o] = (0.5 - (gain / 2.0) + self.state[o] * gain)

    def fetch(self):
        &#34;&#34;&#34;
        Concatenates the states of each neuron for this forward pass into an array.
        Returns:
            `output`: control values to be sent to motors (double[])
        &#34;&#34;&#34;
        output = []
        for o in range(self.outputs):
            output.append(self.state[o])
        # returns the output from all output nodes
        print(&#34;Output from outputPorts: &#34;, output)
        return output</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="RoboViz.ann.feed"><code class="name flex">
<span>def <span class="ident">feed</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<div class="desc"><p>Feeds the network with an array of inputs from the sensors. Only initializes the network's current input variable.</p>
<h2 id="args">Args</h2>
<p><code>input</code>: the number of input neurons (int[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feed(self, input):
    &#34;&#34;&#34;
    Feeds the network with an array of inputs from the sensors. Only initializes the network&#39;s current input variable.

    Args:
        `input`: the number of input neurons (int[])
    &#34;&#34;&#34;
    self.input = []
    print(&#34;Creating brain . . .&#34;)
    print(&#34;Input from sensors: &#34;, input)
    for i in range(self.inputs):
        self.input.append(input[i])</code></pre>
</details>
</dd>
<dt id="RoboViz.ann.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates the states of each neuron for this forward pass into an array.</p>
<h2 id="returns">Returns</h2>
<p><code>output</code>: control values to be sent to motors (double[])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self):
    &#34;&#34;&#34;
    Concatenates the states of each neuron for this forward pass into an array.
    Returns:
        `output`: control values to be sent to motors (double[])
    &#34;&#34;&#34;
    output = []
    for o in range(self.outputs):
        output.append(self.state[o])
    # returns the output from all output nodes
    print(&#34;Output from outputPorts: &#34;, output)
    return output</code></pre>
</details>
</dd>
<dt id="RoboViz.ann.initNetwork"><code class="name flex">
<span>def <span class="ident">initNetwork</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the input and output states in the neural network to 0.</p>
<p>The state is the output of each neuron in the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initNetwork(self):
    &#34;&#34;&#34;
    Initializes the input and output states in the neural network to 0.

    The state is the output of each neuron in the network.
    &#34;&#34;&#34;
    self.state = []
    # Initialize states
    for o in range(self.outputs):
        self.state.append(0.0)

    # Initialize inputs
    for i in range(self.inputs):
        self.state.append(0.0)</code></pre>
</details>
</dd>
<dt id="RoboViz.ann.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Feeds the input data into the neural network. For each input from a sensor, the data is fed into the corresponding neuron and transformed via its activation function.
This data is propogated through the network to the output layer. The state of each neuron is changed accordingly.</p>
<h2 id="args">Args</h2>
<p><code>time</code>: from the python.time() library, used to set the state for the oscillator neurons (float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, time):
    &#34;&#34;&#34;
    Feeds the input data into the neural network. For each input from a sensor, the data is fed into the corresponding neuron and transformed via its activation function.
    This data is propogated through the network to the output layer. The state of each neuron is changed accordingly.

    Args:
        `time`: from the python.time() library, used to set the state for the oscillator neurons (float)
    &#34;&#34;&#34;
    PI = math.pi
    baseIndexOutputWeights = (self.outputs)*(self.inputs)
    # For each hidden and output neuron, sum the state of all incoming connections
    self.activations = []
    for o in range(self.outputs):
        self.activations.append(o)
        for i in range(self.inputs):
            self.activations[o] = self.activations[o]+self.weights[(self.outputs-1)*i+o]*self.state[i]
        for i in range(self.outputs):
            self.activations[o] = self.activations[o]+self.weights[baseIndexOutputWeights]+(self.outputs-1)*i+o*self.state[i]
    # Add in biases and calculate new network state/do appropriate operation for neuron type

    for o in range(self.outputs):
        # save the next state
        if self.Types[o] == 1:
            # params are bias and gain
            self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
            self.state[o] = (1.0/(1.0 + math.exp(-1*(self.params[self.MAX_PARAMS*o+1]))))*self.activations[o]
        elif self.Types[o] == 0:
            # linear, params are bias and gain
            self.activations[o] = self.activations[o]-self.params[self.MAX_PARAMS*o]
            self.state[o] = self.params[self.MAX_PARAMS*o+1]*self.activations[o]
        elif(self.Types[o] == 3):
            # params are period, phase offset, gain (amplitude)
            period = self.params[self.MAX_PARAMS * o]
            phaseOffset = self.params[self.MAX_PARAMS * o + 1]
            gain = self.params[self.MAX_PARAMS * o + 2]
            self.state[o] = ((math.sin((2.0 * PI / period)*(time - period * phaseOffset))) + 1.0) / 2.0
            self.state[o] = (0.5 - (gain / 2.0) + self.state[o] * gain)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="RoboViz.formatCollisions" href="#RoboViz.formatCollisions">formatCollisions</a></code></li>
<li><code><a title="RoboViz.formatOutOfBounds" href="#RoboViz.formatOutOfBounds">formatOutOfBounds</a></code></li>
<li><code><a title="RoboViz.slotSwap" href="#RoboViz.slotSwap">slotSwap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="RoboViz.Brick" href="#RoboViz.Brick">Brick</a></code></h4>
</li>
<li>
<h4><code><a title="RoboViz.Connection" href="#RoboViz.Connection">Connection</a></code></h4>
<ul class="">
<li><code><a title="RoboViz.Connection.as_dict" href="#RoboViz.Connection.as_dict">as_dict</a></code></li>
<li><code><a title="RoboViz.Connection.standardiseSlots" href="#RoboViz.Connection.standardiseSlots">standardiseSlots</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.Environment" href="#RoboViz.Environment">Environment</a></code></h4>
<ul class="two-column">
<li><code><a title="RoboViz.Environment.displayLabel" href="#RoboViz.Environment.displayLabel">displayLabel</a></code></li>
<li><code><a title="RoboViz.Environment.enlargeLabel" href="#RoboViz.Environment.enlargeLabel">enlargeLabel</a></code></li>
<li><code><a title="RoboViz.Environment.finalizeExit" href="#RoboViz.Environment.finalizeExit">finalizeExit</a></code></li>
<li><code><a title="RoboViz.Environment.initialView" href="#RoboViz.Environment.initialView">initialView</a></code></li>
<li><code><a title="RoboViz.Environment.moveCamera" href="#RoboViz.Environment.moveCamera">moveCamera</a></code></li>
<li><code><a title="RoboViz.Environment.moveRobot" href="#RoboViz.Environment.moveRobot">moveRobot</a></code></li>
<li><code><a title="RoboViz.Environment.renderRobot" href="#RoboViz.Environment.renderRobot">renderRobot</a></code></li>
<li><code><a title="RoboViz.Environment.reposition" href="#RoboViz.Environment.reposition">reposition</a></code></li>
<li><code><a title="RoboViz.Environment.select" href="#RoboViz.Environment.select">select</a></code></li>
<li><code><a title="RoboViz.Environment.stepNetwork" href="#RoboViz.Environment.stepNetwork">stepNetwork</a></code></li>
<li><code><a title="RoboViz.Environment.switchFocus" href="#RoboViz.Environment.switchFocus">switchFocus</a></code></li>
<li><code><a title="RoboViz.Environment.toggleBounding" href="#RoboViz.Environment.toggleBounding">toggleBounding</a></code></li>
<li><code><a title="RoboViz.Environment.toggleLabels" href="#RoboViz.Environment.toggleLabels">toggleLabels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.Hinge" href="#RoboViz.Hinge">Hinge</a></code></h4>
</li>
<li>
<h4><code><a title="RoboViz.Robot" href="#RoboViz.Robot">Robot</a></code></h4>
<ul class="">
<li><code><a title="RoboViz.Robot.drawBounds" href="#RoboViz.Robot.drawBounds">drawBounds</a></code></li>
<li><code><a title="RoboViz.Robot.outOfBoundsDetect" href="#RoboViz.Robot.outOfBoundsDetect">outOfBoundsDetect</a></code></li>
<li><code><a title="RoboViz.Robot.setBounds" href="#RoboViz.Robot.setBounds">setBounds</a></code></li>
<li><code><a title="RoboViz.Robot.step" href="#RoboViz.Robot.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.RobotComp" href="#RoboViz.RobotComp">RobotComp</a></code></h4>
<ul class="">
<li><code><a title="RoboViz.RobotComp.as_dict" href="#RoboViz.RobotComp.as_dict">as_dict</a></code></li>
<li><code><a title="RoboViz.RobotComp.calcAcceleration" href="#RoboViz.RobotComp.calcAcceleration">calcAcceleration</a></code></li>
<li><code><a title="RoboViz.RobotComp.calcPos" href="#RoboViz.RobotComp.calcPos">calcPos</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.RobotGUI" href="#RoboViz.RobotGUI">RobotGUI</a></code></h4>
<ul class="two-column">
<li><code><a title="RoboViz.RobotGUI.build_window" href="#RoboViz.RobotGUI.build_window">build_window</a></code></li>
<li><code><a title="RoboViz.RobotGUI.connection_window" href="#RoboViz.RobotGUI.connection_window">connection_window</a></code></li>
<li><code><a title="RoboViz.RobotGUI.error_window" href="#RoboViz.RobotGUI.error_window">error_window</a></code></li>
<li><code><a title="RoboViz.RobotGUI.help_window" href="#RoboViz.RobotGUI.help_window">help_window</a></code></li>
<li><code><a title="RoboViz.RobotGUI.runSim" href="#RoboViz.RobotGUI.runSim">runSim</a></code></li>
<li><code><a title="RoboViz.RobotGUI.startGUI" href="#RoboViz.RobotGUI.startGUI">startGUI</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.RobotUtils" href="#RoboViz.RobotUtils">RobotUtils</a></code></h4>
<ul class="two-column">
<li><code><a title="RoboViz.RobotUtils.autoPack" href="#RoboViz.RobotUtils.autoPack">autoPack</a></code></li>
<li><code><a title="RoboViz.RobotUtils.collisionDetect" href="#RoboViz.RobotUtils.collisionDetect">collisionDetect</a></code></li>
<li><code><a title="RoboViz.RobotUtils.configParse" href="#RoboViz.RobotUtils.configParse">configParse</a></code></li>
<li><code><a title="RoboViz.RobotUtils.createBrain" href="#RoboViz.RobotUtils.createBrain">createBrain</a></code></li>
<li><code><a title="RoboViz.RobotUtils.posParse" href="#RoboViz.RobotUtils.posParse">posParse</a></code></li>
<li><code><a title="RoboViz.RobotUtils.robotParse" href="#RoboViz.RobotUtils.robotParse">robotParse</a></code></li>
<li><code><a title="RoboViz.RobotUtils.writeRobot" href="#RoboViz.RobotUtils.writeRobot">writeRobot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="RoboViz.ann" href="#RoboViz.ann">ann</a></code></h4>
<ul class="">
<li><code><a title="RoboViz.ann.feed" href="#RoboViz.ann.feed">feed</a></code></li>
<li><code><a title="RoboViz.ann.fetch" href="#RoboViz.ann.fetch">fetch</a></code></li>
<li><code><a title="RoboViz.ann.initNetwork" href="#RoboViz.ann.initNetwork">initNetwork</a></code></li>
<li><code><a title="RoboViz.ann.step" href="#RoboViz.ann.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>